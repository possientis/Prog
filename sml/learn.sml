
(* ';' required to end statements at global level *)
val x = 2           (* not a 'scala' 'val', can be reassigned *)
val x = 3           (* that's ok *)
val y = 3 + x

val z = 4 and u = 6; (* syntactic and *)
val (x0,x1) = (2,3); (* pattern matching *)

val x2 = 6 div 2;    (* euclidean division *)
val x3 = 6 * 2;
val x4 = 3 + 8;
val x5 =  2 - x2    (* binary minus *)
val x6 = ~4         (* different symbol for unary minus *)
val x7 = 2.3        (* x7 : real *)

val x8 = let
  val x = 7          (* trailing ';' optional *)                
  val y = 3          (* trailing ';' optional *)
in
  (x + 2 * y) div 3  (* can't have ';' before 'end' *)
end                  (* trailing ';' optional *)

val a = true and b = false; (* a : bool, b : bool *)

val c = (a andalso b) orelse ((not a) andalso (not b)) (* logical 'and' *)

val d = true orelse true (* logical 'or', d = true , this is NOT a 'xor' *)

val a0 = (3 = 2)         (* not '==', but '=' *)
val a1 = (3 <= 2)
val a2 = (3 >= 2)
val a4 = (3 < 2)
val a5 = (3 > 2)
val a6 = (3 <> 2)        (* nor '!=' nor '/=' *) 

val x9 = if 6 < 7 then ~1 else 4; (* no 'if(...)' no 'end' *)

fun add3(x) = x + 3   (* no trailing ';' *)

val x10 = add3(10)
val x11 = add3 10
val x12 = (add3 10)

fun wrongAdd3(7) = 2
  | wrongAdd3(x) = 3 + x  (* pattern matching , '|' stands for 'or' *)

val x13 = wrongAdd3 10
val x14 = wrongAdd3 7

fun even(0) = true
  | even(n) = not(even(n-1))  (* may wish to revise algorithm *)

val a7 = even 13

fun add(x,y) = x + y

val x15 = add (2,3);  (* one tuple argument, no currying *)
val x16 = (2,3)      (* tuple (2,3) : int*int *)

fun curryAdd(x)(y) = x + y 
val x17 = curryAdd 3 7
val x18 = curryAdd 3  (* val f0 = fn : int -> int *)
val x19 = x18(7)

val x20 = fn x => x + 3
val x21 = (fn x => x + 3)
val x22 = x20(7)
val x23 = x21(7); val x24 = 5;

(*fun realAdd(x: real, y:real)  = x + y (* enforcing '+' to be for reals *)
val x24 = add (2.3, 3.4)
fails ...*)

val tup = (true, 7, 3.4) (*  : bool*int*real *)

val L = [1,2,3] (* int list , not 'list int' or 'List int' *)

val l0 = 3::L  (* '::' like scala, 'cons' in Lisp or ':' in haskell *)
val l1 = 3::2::8::nil
val l2 = [] (* : 'a list *)
val l3 = nil
val x24 = (l2 = l3) (* true: bool *)

fun first(x,y) = x (* : 'a * 'b -> 'a * , parametric polymorphism = templates?*)
(* ad-hoc polymorphism = overloading? *) (* type variable uses single quote *)

fun listFirst([x])        = x
  | listFirst(head::tail) = head (* pattern matching again  : 'a list -> 'a *)

val x25 = listFirst [3,2,4]

fun member(x, nil)         = false
  | member(x,(head::tail)) = if x = head then true else member(x,tail)

val x26 = member(3,[5,6,7,8,3,4])

datatype maths = algebra | analysis | logic | computation

fun awesome(algebra)    = true
  | awesome(analysis)   = false
  | awesome(logic)      = false
  | awesome(computation)= true  (* : maths -> bool *)

val x27 = awesome logic

datatype language = functional of string*bool
                  | imperative of string
                  | other
(* all of type language *)
val haskell = functional("Haskell", true) and
    java    = imperative("Java")  and
    prolog  = other

datatype 'a tree = empty
                 | leaf of 'a
                 | node of ('a tree) * 'a * ('a tree)

val t0 = node(node(leaf(2), 3, leaf(4)), 6, leaf(8)) (* : int tree *)

fun breath(empty)   = 0 (* total number of leaves *)
  | breath(leaf(_)) = 1
  | breath(node(left, _, right)) = breath(left) + breath(right)

val x28 = breath(t0)


fun depth(empty)    = 0
  | depth(leaf(_))  = 1
  | depth(node(left, _,right)) = 
    let
      val (ld,rd) = (1 + depth(left), 1 + depth(right))
    in
      if ld > rd then ld else rd
    end

val x29 = depth(t0)

(* watch out for append operator '@' (not '++' nor '+') *)
fun flatten(empty)    = []
  | flatten(leaf(x))  = [x]
  | flatten(node(left,x,right)) = flatten(left) @ (x:: flatten(right))

val x30 = flatten(t0)

(* tree sort algorithm: insert into ordered tree from unordered list *)
(* then flatten the tree *)


fun insert(x, empty) = leaf(x)
  | insert(y,leaf(x)) = if x <= y 
                        then node(empty,x,leaf(y)) 
                        else node(leaf(y), x, empty)
  | insert(y, node(left, x, right)) = 
                        if x <= y
                        then node(left, x, insert(y, right))
                        else node(insert(y,left),x, right)
(* in view of order of arguments in insert, surprised foldl works too *)
fun sort(L) = flatten(foldr(insert)(empty)(L)) (* foldl works too!! *) 
val x31 = sort([2,4,1,5,7,5,9,12,3,5,6])

(***************************** monoids *******************************
 note that the type 'a list, or [A] (in haskell terms with A = 'a) 
 is the free monoid generated by A (viewed as a set of value), hence
 given a monoid B and a map g0: A -> B, there exists a unique
 monoid homomorphism g:[A] -> B such that g.i = g0, where i: A -> [A]
 is the injection. The operation: g0 -> g is called 'lifting' *)

fun listMonoidLift(f:('a->'b), combine: ('b * 'b -> 'b), id: 'b) =
let
  fun f'(nil) = id
    | f'(head::tail) = combine(f(head),f'(tail))
in
  f'
end

(* (int, plus, 0) is a monoid, so the idendity i: int->int
* induces a moinod homomorphism [int] -> int *)

fun plus(x,y) = x + y
val sum = listMonoidLift((fn x => x), plus, 0)

val x32 = sum [2,4,1,2,6]
(* the function g0: int -> int, g0(x) = 1 forall x
* also induces a monoid homomorphism [int] -> int *)

val length = listMonoidLift(fn (x:int) => 1, plus, 0)

val x33 = length [0,2,3,5,6,7,8,10,3]


fun member(x) = listMonoidLift(fn y => y = x, fn (a,b) => a orelse b, false)
val x34 = member(23) [2,4,5,6,7,3,23,0,1]


(* exercise: write 'map' as a listMonoidLift *)



































