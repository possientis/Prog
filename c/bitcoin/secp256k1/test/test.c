#include "test.h"
#include <stdio.h>
#include <assert.h>

callback_t callback_data;

secp256k1_context *ctx;

// valid key
const unsigned char *pubkey_bytes1 = "\x03"
  "\xf0\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a";

// valid key
const unsigned char *pubkey_bytes2 = "\x02" 
  "\xf0\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a";

// invalid key: leading byte 0x04 (uncompressed), expecting 65 bytes
const unsigned char *pubkey_bytes3 = "\x04"
  "\xf0\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a";

// valid key
const unsigned char *pubkey_bytes4 = "\x04"  
  "\xf0\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a"
  "\x07\xcf\x33\xda\x18\xbd\x73\x4c\x60\x0b\x96\xa7\x2b\xbc\x47\x49"
  "\xd5\x14\x1c\x90\xec\x8a\xc3\x28\xae\x52\xdd\xfe\x2e\x50\x5b\xdb";

// invalid key: typo 0xff on second byte
const unsigned char *pubkey_bytes5 = "\x04"
  "\xff\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a"
  "\x07\xcf\x33\xda\x18\xbd\x73\x4c\x60\x0b\x96\xa7\x2b\xbc\x47\x49"
  "\xd5\x14\x1c\x90\xec\x8a\xc3\x28\xae\x52\xdd\xfe\x2e\x50\x5b\xdb";

// valid key: typo 0xff on second byte, but valid
const unsigned char *pubkey_bytes6 = "\x03" 
   "\xff\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
   "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a";


const unsigned char *sig_bytes1 = 
    "\x98\x62\x10\xb9\xdc\x0a\x2f\x21\xbc\xae\xc0\x96\xf4\xf5\x5f\xf4"
    "\x48\x6f\xcc\x4e\x3a\xaf\xe7\xe0\xcb\xf6\x46\x92\x59\x6e\x99\x4a"
    "\x0e\x5c\x6e\xc6\x54\x08\xd6\x5a\xae\x9e\x1c\xe8\xe9\x53\xc3\x1e"
    "\xd0\x3f\x41\x79\x09\x1d\x20\xd1\x59\xda\xe4\x19\xe9\x0c\xa3\x63";

  // non-normalized counterpart of sig_bytes1
  const unsigned char *sig_bytes2 = 
    "\x98\x62\x10\xb9\xdc\x0a\x2f\x21\xbc\xae\xc0\x96\xf4\xf5\x5f\xf4"
    "\x48\x6f\xcc\x4e\x3a\xaf\xe7\xe0\xcb\xf6\x46\x92\x59\x6e\x99\x4a"
    "\xf1\xa3\x91\x39\xab\xf7\x29\xa5\x51\x61\xe3\x17\x16\xac\x3c\xdf"
    "\xea\x6f\x9b\x6d\xa6\x2b\x7f\x6a\x65\xf7\x7a\x72\xe7\x29\x9d\xde";

  const unsigned char *hash_bytes1 = 
    "\x7f\x83\xb1\x65\x7f\xf1\xfc\x53\xb9\x2d\xc1\x81\x48\xa1\xd6\x5d"
    "\xfc\x2d\x4b\x1f\xa3\xd6\x77\x28\x4a\xdd\xd2\x00\x12\x6d\x90\x69";

  const unsigned char *hash_bytes2 =  /* typo in first byte */
    "\xff\x83\xb1\x65\x7f\xf1\xfc\x53\xb9\x2d\xc1\x81\x48\xa1\xd6\x5d"
    "\xfc\x2d\x4b\x1f\xa3\xd6\x77\x28\x4a\xdd\xd2\x00\x12\x6d\x90\x69";
   
  // private key from Mastering Bitcoin
  const unsigned char* priv_bytes1 =
    "\x1e\x99\x42\x3a\x4e\xd2\x76\x08\xa1\x5a\x26\x16\xa2\xb0\xe9\xe5"
    "\x2c\xed\x33\x0a\xc5\x30\xed\xcc\x32\xc8\xff\xc6\xa5\x26\xae\xdd";

  // expected rfc6969 nonce from hash_bytes1 and priv_bytes1 
  // see java EC_Test_Utils.getDeterministicKey and Test18.java
  const unsigned char* nonce_bytes1 = 
    "\x8b\x87\x1e\x0f\x28\x6b\x37\x91\xab\xb6\xe1\xd7\xc2\x8e\x6c\x7e"
    "\x07\x19\x82\x9e\xfc\x03\xf6\x09\x4f\x70\xda\xb1\xb0\xf0\x0e\xfb";





void default_callback(const char* message, void* data){

  const char* default_message = "<no message>";
  assert(data != NULL);

  const char* msg = ((callback_t*) data)->in;
  if(msg == NULL) msg = default_message;

  fprintf(stderr, "%s: callback function is rightly called: %s\n", msg, message);

  ((callback_t*) data)->out = 42;  
}

int is_all_null(const void *ptr, size_t size)
{
  assert(ptr != NULL);
  assert(size >= 0);

  const unsigned char *p = ptr;

  size_t i;
  for(i = 0; i < size; ++i)
  {
    if( *p++ != '\x00' ) return 0;
  }

  return 1;
}

int test_setup(){

  ctx = secp256k1_context_create
      ( SECP256K1_CONTEXT_VERIFY 
      | SECP256K1_CONTEXT_SIGN
      );

  secp256k1_context_set_illegal_callback(ctx,default_callback, &callback_data);

  secp256k1_context_set_error_callback(ctx,default_callback, &callback_data);

  assert(ctx != NULL);

  return 0;
}

