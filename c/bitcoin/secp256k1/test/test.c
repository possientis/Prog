#include "test.h"
#include <stdio.h>
#include <assert.h>

int callback_data;

secp256k1_context *ctx;

// valid key
const unsigned char *pubkey_bytes1 = "\x03"
  "\xf0\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a";

// valid key
const unsigned char *pubkey_bytes2 = "\x02" 
  "\xf0\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a";

// invalid key: leading byte 0x04 (uncompressed), expecting 65 bytes
const unsigned char *pubkey_bytes3 = "\x04"
  "\xf0\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a";

// valid key
const unsigned char *pubkey_bytes4 = "\x04"  
  "\xf0\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a"
  "\x07\xcf\x33\xda\x18\xbd\x73\x4c\x60\x0b\x96\xa7\x2b\xbc\x47\x49"
  "\xd5\x14\x1c\x90\xec\x8a\xc3\x28\xae\x52\xdd\xfe\x2e\x50\x5b\xdb";

// invalid key: typo 0xff on second byte
const unsigned char *pubkey_bytes5 = "\x04"
  "\xff\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
  "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a"
  "\x07\xcf\x33\xda\x18\xbd\x73\x4c\x60\x0b\x96\xa7\x2b\xbc\x47\x49"
  "\xd5\x14\x1c\x90\xec\x8a\xc3\x28\xae\x52\xdd\xfe\x2e\x50\x5b\xdb";

// valid key: typo 0xff on second byte, but valid
const unsigned char *pubkey_bytes6 = "\x03" 
   "\xff\x28\x89\x2b\xad\x7e\xd5\x7d\x2f\xb5\x7b\xf3\x30\x81\xd5\xcf"
   "\xcf\x6f\x9e\xd3\xd3\xd7\xf1\x59\xc2\xe2\xff\xf5\x79\xdc\x34\x1a";

void default_callback(const char* message, void* data){
  fprintf(stderr, "callback function is rightly called: %s\n", message);
  *((int*) data) = 42;
}

int is_all_null(const void *ptr, size_t size)
{
  assert(ptr != NULL);
  assert(size >= 0);

  const unsigned char *p = ptr;

  size_t i;
  for(i = 0; i < size; ++i)
  {
    if( *p++ != '\x00' ) return 0;
  }

  return 1;
}

int test_setup(){

  ctx = secp256k1_context_create
      ( SECP256K1_CONTEXT_VERIFY 
      | SECP256K1_CONTEXT_SIGN
      );

  secp256k1_context_set_illegal_callback(ctx,default_callback, &callback_data);

  secp256k1_context_set_error_callback(ctx,default_callback, &callback_data);

  assert(ctx != NULL);

  return 0;
}

