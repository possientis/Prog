{
{-# LANGUAGE FlexibleContexts #-}

module Lexer (
    Token(..),
    scanTokens
) where

import Syntax
import Control.Monad.Except

}

%wrapper "basic"

$digit = 0-9
$alpha = [a-zA-Z]
$eol   = [\n]

tokens :-

    -- whitespace insensitive
    $eol                            ;
    $white+                         ;

    -- comments
    "#".*                           ;

    -- syntax
    let                             { \s -> TokenLet }
    True                            { \s -> TokenTrue }
    False                           { \s -> TokenFalse }
    in                              { \s -> TokenIn }
    $digit+                         { \s -> TokenNum (read s) }
    "->"                            { \s -> TokenArrow }
    \=                              { \s -> TokenEq }
    \\                              { \s -> TokenLambda }
    [\+]                            { \s -> TokenAdd }
    [\-]                            { \s -> TokenSub }
    [\*]                            { \s -> TokenMul }
    \(                              { \s -> TokenLParen }
    \)                              { \s -> TokenRParen }
    $alpha [$alpha $digit \_ \']*   { \s -> TokenSym s }

{

data Token 
  = TokenLet
  | TokenTrue
  | TokenFalse
  | TokenIn
  | TokenLambda
  | TokenNum Int
  | TokenSym String
  | TokenArrow
  | TokenEq
  | TokenAdd
  | TokenSub
  | TokenMul
  | TokenLParen
  | TokenRParen
  | TokenEOF
  deriving (Eq,Show)

scanTokens :: String -> Except String [Token]
scanTokens str = go ('\n',[],str) where
    go inp@(_,_bs,str) =
        case alexScan inp 0 of
            AlexEOF -> return []
            AlexError _ -> throwError "Invalid lexeme."
            AlexSkip inp' len   -> go inp'
            AlexToken inp' len act -> do
                res <- go inp'
                let rest = act (take len str)
                return (rest : res)

}
