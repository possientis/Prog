when evaluating a variable which is bound to a thunk, it seems we need to return
the thunk without forcing it. So variable.scm is fine and cannot be changed. see debug.scm for example. However, this means we need to fix unit-test


test the following code in lazy mode (after fixing define)
(define x 1)
(set! x (+ x x))
(display x)(newline)

continue rewriting unit-test

understand possible dissymetry of include between "analyze.scm" and "strict/lazy-eval.scm". do we need to create new type of procedure? strict-eval-procedure v lazy-eval-procedure? (see application.scm for obvious dissymetry, should there be a strict-apply, analyze-apply, lazy-appply?)
analyze: review code and understand why no pick up in perf

lazy-repl:
(define (error) (display "This is an error\n"))
understand why:
> (error) 
fails

(define (try a b) (if (= 0 a) 1 b))
compare lazy and strict eval of
> (try 0 (error))




define primitives from language itself
implement macros
lazy evaluation of arguments (with or without memoization)
change semantics of apply
check semantics of '() vs ()
incorporate frame4 with hash-table library

