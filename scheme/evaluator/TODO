check 'eval' and 'load' on scm and slib.
design an example of code with an 'eval' statement within the body of a function  

continue writing comment in strict-load.scm
loading global-env in lazy mode fails
unit-test: load (called directly) and load (by eval)

why is new-apply being called at all ... well it is called in new-map...

test the following code in lazy mode (after fixing define)
(define x 1)
(set! x (+ x x))
(display x)(newline)

continue rewriting unit-test

understand possible dissymetry of include between "analyze.scm" and "strict/lazy-eval.scm". do we need to create new type of procedure? strict-eval-procedure v lazy-eval-procedure? (see application.scm for obvious dissymetry, should there be a strict-apply, analyze-apply, lazy-appply?)
analyze: review code and understand why no pick up in perf

lazy-repl:
(define (error) (display "This is an error\n"))
understand why:
> (error) 
fails

(define (try a b) (if (= 0 a) 1 b))
compare lazy and strict eval of
> (try 0 (error))




define primitives from language itself
implement macros
lazy evaluation of arguments (with or without memoization)
change semantics of apply
check semantics of '() vs ()
incorporate frame4 with hash-table library

