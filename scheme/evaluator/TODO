create strict-apply and analyze-apply  along the lines of lazy apply

we now have strict analayze lazy version of apply for each three categories of func object

eval-procedure: need strict and analyze version of apply-eval-proc

application: why are strict-eval application and analyze-application calling new-apply while lazy-eval-application is calling lazy-apply...

look at debug: find out why code returns a thunk, and not a value

strict-eval depends on eval-mode when it should not. This is probably due to the 
fact that strict-eval has dependency to new-apply which depends on eval-mode

unit-test definition (syntactic sugar for function def)

test the following code in lazy mode (after fixing define)
(define x 1)
(set! x (+ x x))
(display x)(newline)

continue rewriting unit-test

understand possible dissymetry of include between "analyze.scm" and "strict/lazy-eval.scm". do we need to create new type of procedure? strict-eval-procedure v lazy-eval-procedure? (see application.scm for obvious dissymetry, should there be a strict-apply, analyze-apply, lazy-appply?)
analyze: review code and understand why no pick up in perf

lazy-repl:
(define (error) (display "This is an error\n"))
understand why:
> (error) 
fails

(define (try a b) (if (= 0 a) 1 b))
compare lazy and strict eval of
> (try 0 (error))




define primitives from language itself
implement macros
lazy evaluation of arguments (with or without memoization)
change semantics of apply
check semantics of '() vs ()
incorporate frame4 with hash-table library

