In order to achieve smooth unit-testing, we felt variable.scm had to be changed 
so that strict evaluation would go beyond a simple look-up and actually force a 
thunk whenever it is encountered. This has created all sort of issues. 
However this change real means that 'thunk expression' should really be part of
the language and be accepted by strict eval. Review this idea and look at debug.scm.



keep debugging via run (crucial change in variable.scm) : unit-test, lazy-eval, thunk have checks
definition unit-test

test the following code in lazy mode (after fixing define)
(define x 1)
(set! x (+ x x))
(display x)(newline)

continue rewriting unit-test

understand possible dissymetry of include between "analyze.scm" and "strict/lazy-eval.scm". do we need to create new type of procedure? strict-eval-procedure v lazy-eval-procedure? (see application.scm for obvious dissymetry, should there be a strict-apply, analyze-apply, lazy-appply?)
analyze: review code and understand why no pick up in perf

lazy-repl:
(define (error) (display "This is an error\n"))
understand why:
> (error) 
fails

(define (try a b) (if (= 0 a) 1 b))
compare lazy and strict eval of
> (try 0 (error))




define primitives from language itself
implement macros
lazy evaluation of arguments (with or without memoization)
change semantics of apply
check semantics of '() vs ()
incorporate frame4 with hash-table library

