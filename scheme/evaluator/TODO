problem with lazy evaluation of begin statement. 
Only the last statement is ever forced.


solve paradox: when runing lazy-eval with scm, we get the right behaviour, unlike what we get with ./lazy-run.sh

(define (try a b) (if (= 0 a) 1 b))
compare lazy and strict eval of
> (try 0 (error))
what happens if we use lazy-run? is lazy-run the same as strict-run? 


define primitives from language itself
implement macros
lazy evaluation of arguments (with or without memoization)
change semantics of apply
check semantics of '() vs ()
incorporate frame4 with hash-table library

