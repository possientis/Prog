(lazy-eval '(f 5)) is a double-thunk 
(body env) is a single thunk
yet we thought they were equivalent code... Explain

can we keep following the thread of execution?

understand failure in test.scm

resolve FAILURE in unit test

unit-test definition (syntactic sugar for function def)

why is new-apply being called at all ... well it is called in new-map...

test the following code in lazy mode (after fixing define)
(define x 1)
(set! x (+ x x))
(display x)(newline)

continue rewriting unit-test

understand possible dissymetry of include between "analyze.scm" and "strict/lazy-eval.scm". do we need to create new type of procedure? strict-eval-procedure v lazy-eval-procedure? (see application.scm for obvious dissymetry, should there be a strict-apply, analyze-apply, lazy-appply?)
analyze: review code and understand why no pick up in perf

lazy-repl:
(define (error) (display "This is an error\n"))
understand why:
> (error) 
fails

(define (try a b) (if (= 0 a) 1 b))
compare lazy and strict eval of
> (try 0 (error))




define primitives from language itself
implement macros
lazy evaluation of arguments (with or without memoization)
change semantics of apply
check semantics of '() vs ()
incorporate frame4 with hash-table library

