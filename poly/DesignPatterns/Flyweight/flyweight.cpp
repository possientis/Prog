// Flyweight Design Pattern 
#include <iostream>
#include <string>
#include <assert.h>
#include <map>

// The main idea of the flyweight design pattern is to store objects
// in a dictionary so they can be reused, rather than new objects be
// created. This pattern is particularly well suited to classes of 
// immutable objects which is the case we shall consider here. Because
// dictionaries cannot exist without keys, the flyweight design pattern
// is closely related to the question of hashing.
//
// We shall consider the example of an inductive type Set with the three
// constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
// Union : Set -> Set -> Set. The type Set therefore corresponds to 
// the free algebra generated by a single element 0 (the empty set) and
// the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
// (inclusion) and equivalence between sets are very important, we shall 
// not consider it here and simply look at elements of type Set as syntactic
// objects. A typical OOP implementation is based on the composite  design 
// pattern which we shall adopt in this example.
//
// Objects (which are immutable) are supposed to be reused, not created.
// So the constructors of the class Set (and its subclasses) should not
// be used directly. Instead, the class should provide static factory 
// functions for 0, {x} and xUy. However, these factory functions should 
// not be simple wrappers around class constructors and should instead 
// check whether an object has previously been created.
//
// Fundamentally, we need to maintain a dictionary of created objects and
// we shall design a separate class SetManager to handle this dictionary.
// In fact the factory functions 0, {x}, xUy will be delegated to the class
// SetManager and Set will simply pass on the client's requests for object
// retrieval (or construction) to SetManager via a static member embedded
// in the class Set. As objects are being created and stored into the 
// manager's dictionary, dynamic hash values will be generated and assigned 
// to objects. The handling of hash values will also be performed by SetManager.
//
// It is possible to consider static algorithms for hash values. However, 
// these often do not guarantee that two objects with equal hash are equal. 
// It is nice to know that a static hash function is a (mathematically) 
// injective mapping. In the case at hand, such function exist but are 
// computationally unusable due to their rapid growth. Using dynamic 
// hashing, although not specifically called for by the flyweight design 
// pattern, provides the convenience of producing truly unique hashes, which 
// grow very slowly (a hash counter is incremented at each object creation). 
//
// So this example illustrate a case of flyweight design pattern, as well
// as proposing a scheme for the generation of dynamic hash values. 

class Set;
class SetManager;

/******************************************************************************/
/*                             SetManager class                               */
/******************************************************************************/

class SetManager {
  private:
    int nextHash;
    std::map<int,int>   singletonMap;
    std::map<int,int>   unionMap;
    std::map<int,Set*>  objectMap;
    SetManager();
  // static
  private:
    static SetManager* _instance;   
  public:
    ~SetManager();
    static SetManager* instance();
    static void resetInstance();
    static int pairingCantor(int x, int y);
    static void debug();
    static Set* zero();
    static Set* singleton(Set* x);
    static Set* setUnion(Set* x, Set* y);
};

/******************************************************************************/
/*                                  Set class                                 */
/******************************************************************************/

class Set {
  // static members
  private:
    static long memory_checksum;
  public:
    static void log(const char* message, const void* address);
    static void debug()                 { SetManager::debug(); }
    static bool hasMemoryLeak()         { return memory_checksum != 0L; }
    static Set* zero()                  { return SetManager::zero(); }
    static Set* singleton(Set* x)       { return SetManager::singleton(x); }
    static Set* setUnion(Set* x, Set* y){ return SetManager::setUnion(x,y); }
    static Set* successor(Set* x)       { return setUnion(x, singleton(x)); }
  // instance members
  private:
    int hash;
    Set(const Set&);            // not implemented
    Set& operator=(const Set&); // not implemented
  protected:
    Set(int hash){ this->hash = hash; }
  public:
    virtual ~Set(){};
    int hashCode(){ return hash; }    // not virtual
    virtual std::string toString()    const = 0;
    virtual bool        isZero()      const = 0;
    virtual bool        isSingleton() const = 0;
    virtual bool        isUnion()     const = 0;
    virtual const Set*  element()     const = 0;
    virtual const Set*  left()        const = 0;
    virtual const Set*  right()       const = 0;
};


/******************************************************************************/
/*                                 Zero class                                 */
/******************************************************************************/

class Zero : public Set {
  friend SetManager;              // only one to call class contructor
  private:
    Zero(int hash) : Set(hash){}
    Zero(const Zero&);            // not implemented
    Zero& operator=(const Zero&); // not implemented
  public:
    ~Zero(){}
    std::string toString()    const override { return "0"; }
    bool        isZero()      const override { return true; } 
    bool        isSingleton() const override { return false; }
    bool        isUnion()     const override { return false; }
    const Set*  element()     const override { assert(false); return nullptr; }
    const Set*  left()        const override { assert(false); return nullptr; }
    const Set*  right()       const override { assert(false); return nullptr; }
};


/******************************************************************************/
/*                               Singleton class                              */
/******************************************************************************/

class Singleton : public Set {
  friend SetManager;
  private:
    const Set* _element;
    Singleton(const Set* x, int hash) : Set(hash), _element(x){}
    Singleton(const Singleton&);            // not implemented
    Singleton& operator=(const Singleton&); // not implemented
  public:
    ~Singleton(){}            // object does not own its element, no deallocation
    std::string toString()    const override;
    bool        isZero()      const override { return false; } 
    bool        isSingleton() const override { return true; }
    bool        isUnion()     const override { return false; }
    const Set*  element()     const override { return _element; }
    const Set*  left()        const override { assert(false); return nullptr; }
    const Set*  right()       const override { assert(false); return nullptr; }
};


/******************************************************************************/
/*                                Union class                                 */
/******************************************************************************/

class Union : public Set {
  friend SetManager;
  private:
    const Set* _left;
    const Set* _right;
    Union(const Set* x, const Set* y, int hash) : Set(hash), _left(x), _right(y){}
    Union(const Union&);            // not implemented
    Union& operator=(const Union&); // not implemented
  public:
    ~Union(){}                // object does not own its data, no deallocation
    std::string toString()    const override;
    bool        isZero()      const override { return false; } 
    bool        isSingleton() const override { return false; }
    bool        isUnion()     const override { return true; }
    const Set*  element()     const override { assert(false); return nullptr; }
    const Set*  left()        const override { return _left; }
    const Set*  right()       const override { return _right; }
};


/******************************************************************************/
/*                                Implementation                              */
/******************************************************************************/



long Set::memory_checksum = 0L; 
void Set::log(const char* message, const void* address){
  assert(message != nullptr);
  assert(address != nullptr);
//  std::cerr << message << ": " << std::hex << address << std::endl;
  memory_checksum ^= (long) address;
}

std::string Singleton::toString() const {
  assert(_element != nullptr);
  return "{" + _element->toString() + "}";
}

std::string Union::toString() const {
  assert(_left  != nullptr);
  assert(_right != nullptr);
  return _left->toString() + "U" + _right->toString();
}


SetManager::SetManager() :  nextHash(1) {
  Set* zero = new Zero(0);
  assert(zero != nullptr);
  Set::log("Allocating Zero object", zero);
  objectMap[0] = zero;
  assert(objectMap[0] == zero);
}

SetManager::~SetManager(){
  //deallocation of sets
  for(int i = 0; i < nextHash; ++i){
    Set* set = objectMap[i];
    Set::log("Deallocating set object", set);
    delete set;
  } 
}


SetManager* SetManager::_instance = nullptr;

void SetManager::resetInstance(){
  if(_instance != nullptr){
    Set::log("Deallocating set manager", _instance);
    delete _instance;
    _instance = nullptr;
  }
}

SetManager* SetManager::instance(){
  if(_instance == nullptr){
    _instance = new SetManager();
    assert(_instance != nullptr);
    Set::log("Allocating new set manager", _instance);
  }
  return _instance;
}

Set* SetManager::zero(){
  SetManager* manager = instance();
  assert(manager != nullptr);
  return manager->objectMap[0];
}

Set* SetManager::singleton(Set* x){
  assert(x != nullptr);
  SetManager* manager = instance();
  assert(manager != nullptr);
  int hash = x->hashCode();
  auto search = manager->singletonMap.find(hash);
  if(search == manager->singletonMap.end()){          // {x} not yet created
    manager->singletonMap[hash] = manager->nextHash;  // allocating nextHash to {x}
    Set* object = new Singleton(x, manager->nextHash);// creating {x}
    assert(object != nullptr);
    Set::log("Allocating new Singleton object", object);
    manager->objectMap[manager->nextHash] = object;
    manager->nextHash++;
    return object;
  } else {  // {x} does exist with hash given by search->second
    return manager->objectMap[search->second];
  }
}

int SetManager::pairingCantor(int x, int y){
  return (x + y + 1)*(x + y)/2 + y; // '/' is integer division
}

Set* SetManager::setUnion(Set* x, Set* y){
  assert(x != nullptr);
  assert(y != nullptr);
  SetManager* manager = instance();
  assert(manager != nullptr);
  int hx = x->hashCode();
  int hy = y->hashCode();
  int hash = SetManager::pairingCantor(hx, hy);
  auto search = manager->unionMap.find(hash);
  if(search == manager->unionMap.end()){              // xUy not yet created
    manager->unionMap[hash] = manager->nextHash;      // allocating nextHash to xUy
    Set* object = new Union(x, y, manager->nextHash); // creating xUy
    assert(object != nullptr);
    Set::log("Allocating new Union object", object);
    manager->objectMap[manager->nextHash] = object;
    manager->nextHash++;
    return object;
  } else {  // xUy does exist with hash given by search->second
    return manager->objectMap[search->second];
  }
}

std::ostream& operator<<(std::ostream& s, Set* set){
  s << set->toString();
  return s;
}

void SetManager::debug(){
  SetManager* manager = instance();
  for(int i = 0; i < manager->nextHash; ++i){
    Set* set = manager->objectMap[i];
    assert(set != nullptr);
    std::cout << "hash = " << i << ": " << set << std::endl;
  }
}

void flyweight_test(){
  Set* zero = Set::zero();
  assert(zero->isZero());
  assert(!zero->isSingleton());
  assert(!zero->isUnion());
  assert(zero->hashCode() == 0);
  assert(zero->toString() == "0");
  Set* zero_ = Set::zero();
  assert(zero_ == zero);

  Set* one = Set::singleton(zero);
  assert(!one->isZero());
  assert(one->isSingleton());
  assert(!one->isUnion());
  assert(one->element()   == zero);
  assert(one->toString()  == "{0}");
  Set* one_ = Set::singleton(Set::zero());
  assert(one_ == one);

  Set* s_one = Set::singleton(one);
  Set* two   = Set::setUnion(one, s_one);
  assert(!two->isZero());
  assert(!two->isSingleton());
  assert(two->isUnion());
  assert(two->hashCode() == 3);
  assert(two->toString() == "{0}U{{0}}");

  
  SetManager::resetInstance();
}

/******************************************************************************/
/*                                    Main                                    */
/******************************************************************************/

int main(){
//  flyweight_test();
  Set* zero   = Set::zero();
  Set* one    = Set::successor(zero);
  Set* two    = Set::successor(one);
  Set* three  = Set::successor(two);
  Set* four   = Set::successor(three);
  Set* five   = Set::successor(four);

  Set::debug();

  SetManager::resetInstance(); // clean up
  assert(!Set::hasMemoryLeak());
  return 0;
}




