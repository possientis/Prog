; Flyweight Design Pattern
(load "dict.scm")
; The main idea of the flyweight design pattern is to store objects
; in a dictionary so they can be reused, rather than new objects be
; created. This pattern is particularly well suited to classes of 
; immutable objects which is the case we shall consider here. Because
; dictionaries cannot exist without keys, the flyweight design pattern
; is closely related to the question of hashing.
;
; We shall consider the example of an inductive type Set with the three
; constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
; Union : Set -> Set -> Set. The type Set therefore corresponds to 
; the free algebra generated by a single element 0 (the empty set) and
; the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
; (inclusion) and equivalence between sets are very important, we shall 
; not consider it here and simply look at elements of type Set as syntactic
; objects. A typical OOP implementation is based on the composite  design 
; pattern which we shall adopt in this example.
;
; Objects (which are immutable) are supposed to be reused, not created.
; So the constructors of the class Set (and its subclasses) should not
; be used directly. Instead, the class should provide static factory 
; functions for 0, {x} and xUy. However, these factory functions should 
; not be simple wrappers around class constructors and should instead 
; check whether an object has previously been created.
;
; Fundamentally, we need to maintain a dictionary of created objects and
; we shall design a separate class SetManager to handle this dictionary.
; In fact the factory functions 0, {x}, xUy will be delegated to the class
; SetManager and Set will simply pass on the client's requests for object
; retrieval (or construction) to SetManager via a static member embedded
; in the class Set. As objects are being created and stored into the 
; manager's dictionary, dynamic hash values will be generated and assigned 
; to objects. The handling of hash values will also be performed by SetManager.
;
; It is possible to consider static algorithms for hash values. However, 
; these often do not guarantee that two objects with equal hash are equal. 
; It is nice to know that a static hash function is a (mathematically) 
; injective mapping. In the case at hand, such function exist but are 
; computationally unusable due to their rapid growth. Using dynamic hashing, 
; although not specifically called for by the flyweight design pattern, 
; provides the convenience of producing truly unique hashes, which grow very 
; slowly (a hash counter is incremented at each object creation). 
;
; So this example illustrate a case of flyweight design pattern, as well
; as proposing a scheme for the generation of dynamic hash values. 


; standard composite pattern with abstract base class, and three concrete
; subclasses corresponding to each constructor of the inductive type Set

(define virtual-table   ; constructor
  (let ((let-for-name-encapsulation 'anything))
    ; object created from data is message passing interface
    (define (this data)
      (lambda (m)
        (cond ((eq? m 'to-string) (to-string data))
              ((eq? m 'zero?)     (is-zero? data))
              ((eq? m 'singleton?)(singleton? data))
              ((eq? m 'union?)    (union? data))
              ((eq? m 'element)   (element data))
              ((eq? m 'left)      (left data))
              ((eq? m 'right)     (right data))
              (else (error "set-virtual-table: unknown operation: " m)))))
    ;
    (define (to-string data)  (cadr data))
    (define (is-zero? data)   (caddr data))
    (define (singleton? data) (cadddr data))
    (define (union? data)     (car (cddddr data)))
    (define (element data)    (car (cdr (cddddr data))))
    (define (left data)       (car (cdr (cdr (cddddr data)))))
    (define (right data)      (car (cdr (cdr (cdr (cddddr data))))))
    ;
    ; returning 7 argument constructor
    ;
    (lambda(a1 a2 a3 a4 a5 a6 a7) (this (list 'data a1 a2 a3 a4 a5 a6 a7)))))


(define set-virtual-table
  (virtual-table
    (lambda (data) (error "set: to-string in not implemented"))
    (lambda (data) (error "set: zero? is not implemented"))
    (lambda (data) (error "set: singleton? is not implemented"))
    (lambda (data) (error "set: union? is not implemented"))
    (lambda (data) (error "set: element is not implemented"))
    (lambda (data) (error "set: left is not implemented"))
    (lambda (data) (error "set: right is not implemented"))))

(define zero-virtual-table
  (virtual-table
    (lambda (data) "0")
    (lambda (data) #t)
    (lambda (data) #f)
    (lambda (data) #f)
    (lambda (data) (error "zero: empty set has no element"))
    (lambda (data) (error "zero: left is not implemented"))
    (lambda (data) (error "zero: right is not implemented"))))

(define singleton-virtual-table
  (virtual-table
    (lambda (data) (string-append "{" ((cadddr data) 'to-string) "}"))
    (lambda (data) #f)
    (lambda (data) #t)
    (lambda (data) #f)
    (lambda (data) (cadddr data))
    (lambda (data) (error "singleton left is not implemented"))
    (lambda (data) (error "singleton right is not implemented"))))

(define union-virtual-table
  (virtual-table
    (lambda (data) 
      (string-append
        ((cadddr data) 'to-string) "U" ((car (cddddr data)) 'to-string)))
    (lambda (data) #f)
    (lambda (data) #f)
    (lambda (data) #t)
    (lambda (data) (error "union: element is not implemented"))
    (lambda (data) (cadddr data))
    (lambda (data) (car (cddddr data)))))


(define set   ; constructor
  ; data is (list
  ; 'data               <- car
  ; hash                <- cadr
  ; v-table             <- caddr
  ; element (or left)   <- cadddr
  ; right               <- (car (cddddr ))

  (let ((let-for-name-encapsulation 'anything))
    ; object created from data is message passing interface
    (define (this data)
      (lambda (m)
        (cond ((eq? m 'hash-code) (hash-code data)) ; not-virtual
              ((eq? m 'to-string) (to-string data))
              ((eq? m 'zero?)     (is-zero? data))
              ((eq? m 'singleton?)(singleton? data))
              ((eq? m 'union?)    (union? data))
              ((eq? m 'element)   (element data))
              ((eq? m 'left)      (left data))
              ((eq? m 'right)     (right data))
              (else (error "set: unknown operation: " m)))))
    ;
    ; implementation of object instance interface
    ;
    (define (hash-code data)  (cadr data))
    (define (v-table data)    (caddr data))
    (define (to-string data)  (((v-table data) 'to-string)  data))
    (define (is-zero? data)   (((v-table data) 'zero?)      data))
    (define (singleton? data) (((v-table data) 'singleton?) data))
    (define (union? data)     (((v-table data) 'union?)     data))
    (define (element data)    (((v-table data) 'element)    data))
    (define (left data)       (((v-table data) 'left)       data))
    (define (right data)      (((v-table data) 'right)      data))
    ;
    ;
    (define manager #f)       ; to be initialized with set-manager object
    ;
    ;
    (define static-interface
      (lambda (m)
        (cond ((eq? m 'set-up-manager)  (set-up-manager))
              ((eq? m 'zero)            (make-zero))
              ((eq? m 'singleton)       (make-singleton))
              ((eq? m 'union)           (make-union))
              ((eq? m 'successor)       (successor))
              ((eq? m 'debug)           (debug))
              ; otherwise returning object instance
              (else  (this m)))))
    ;
    ; implementation of static interface 
    ;
    (define (set-up-manager)  (set! manager (set-manager)))
    (define (make-zero)       (manager 'zero))        ; delegating to manager
    (define (make-singleton)  (manager 'singleton))   ; delegating to manager
    (define (make-union)      (manager 'union))       ; delegating to manager
    (define (debug)           (manager 'debug))       ; delegating to manager
    ;
    (define (successor) 
      (lambda (x) ((set 'union) x ((set 'singleton) x))))
    ;
    ; returning interface
    ;
    static-interface))


(define zero      ; constructor
  ; returning single argument constructor
  (lambda (hash)
    (let ((data (list 'data hash zero-virtual-table)))
      (set data))))

(define singleton ; constructor
  ; returning two arguments contructor
  (lambda (x hash)
    (let ((data (list 'data hash singleton-virtual-table x)))
      (set data))))

(define union     ; constructor
  ; returning three arguments constructor
  (lambda (x y hash)
    (let ((data (list 'data hash union-virtual-table x y)))
      (set data))))


; The manager maintains various dictionaries. The main dictionary is objectMap,
; which given a hash code, returns a previously constructed object. However,
; The manager needs to implement the factory methods corresponding to the 
; three constructors of the inductive type Set. Implementing the zero()
; method is easy. The manager always assigns 0 as its hash code and creates
; a single object which is stored once and for all in the objectMap dictionary.
; The method zero() simply returns a reference to the existing object.
; In order to implement singleton(x) (returning the object {x} from x), the 
; manager needs to quickly establish whether (given the set x and its hash code)
; the set {x} has already been created. However, the manager cannot simply query
; the objectMap dictionary because it does not know what dynamic hash code the
; singleton {x} was assigned (assuming it already exists). This is why the 
; manager maintains an additional dictionary 'singletonMap' which stores the 
; hash code of {x} given the hash code of x. Hence by querying the dictionary 
; singletonMap, the manager is able to establish whether {x} already exists, 
; and if so, what its hash code is. Given the hash code of {x} it can simply 
; query objectMap and return the appropriate object. In the case when the object
; {x} does not already exist, the manager assigns the current value of 
; 'nextHash' to the object {x}, then creates the object using this hash value, 
; and before it returns the object, the manager updates objectMap with the new 
; object and singletonMap with the link between the hash of x and that of {x}. 
; In order to implement the factory method union(x,y), a similar scheme is 
; adopted which requires a new dictionary unionMap. This map could have been 
; implemented with pairs as keys, but we decided to keep using integers, and 
; simply map pairs of ints to ints with the Cantor function.


(define set-manager   ; constructor
  (let ((let-for-name-encapsulation 'anything))
    ; object created from data is message passing interface
    (define (this data)
      (lambda (m)
        (cond ((eq? m 'zero)      (return-zero data))
              ((eq? m 'singleton) (return-singleton data))
              ((eq? m 'union)     (return-union data))
              ((eq? m 'debug)     (debug data))
              (else (error "set-manager: unknown operation: " m)))))
    ;
    ; implementation of object interface
    ;
    (define (return-zero data) (cdr (((object-map data) 'find) 0)))
    ;
    (define (return-singleton data)
      (lambda (x)
        (let ((next-hash     (next-hash data))
              (singleton-map (singleton-map data))
              (object-map    (object-map data))
              (hash          (x 'hash-code)))
          (let ((mapped-hash ((singleton-map 'find) hash)))
            (if (eq? #f mapped-hash)  
              ; singleton {x} is unknown
              (begin
                ; next-hash is allocated to {x}
                ((singleton-map 'insert!) hash next-hash)
                ; creating singleton object {x}
                (let ((object (singleton x next-hash)))
                  ; saving {x} for future reference
                  ((object-map 'insert!) next-hash object)
                  ; incrementing next-hash for future hash allocation
                  (increment-hash data)
                  ; returning object
                  object))
              ; else, singleton {x} is known, simply retrieving it from hash
              (cdr ((object-map 'find) (cdr mapped-hash))))))))
    ;
    (define (return-union data)
      (lambda (x y)
        (let ((next-hash      (next-hash data))
              (union-map      (union-map data))
              (object-map     (object-map data))
              (hash-x         (x 'hash-code))
              (hash-y         (y 'hash-code)))
          (let ((hash (pairing-cantor hash-x hash-y)))
            (let ((mapped-hash ((union-map 'find) hash)))
              (if (eq? #f mapped-hash)
                ; union xUy is unknown
                (begin
                  ; next-hash is allocated to xUy
                  ((union-map 'insert!) hash next-hash)
                  ; creating union object xUy
                  (let ((object (union x y next-hash)))
                    ; saving xUy for future reference
                    ((object-map 'insert!) next-hash object)
                    ; incrementing next-hash for future hash allocation
                    (increment-hash data)
                    ; returning object
                    object))
                ; else, union xUy is known, simply retrieving it from hash
                (cdr ((object-map 'find) (cdr mapped-hash)))))))))
    ;
    (define (debug data)
      (let ((next-hash  (next-hash data))
            (object-map (object-map data)))
        (let loop ((i 0))
          (if (< i next-hash)
            (begin
              (display "hash = ")(display i)(display ": ")
              (display ((cdr ((object-map 'find) i)) 'to-string))
              (newline)
              (loop (+ i 1)))))))
    ;
    ; helper functions
    ;
    (define (increment-hash data) (set-car! (cdr data) (+ 1 (cadr data))))
    (define (pairing-cantor x y)  (+ y (quotient (* (+ x y 1) (+ x y)) 2)))
    (define (next-hash      data) (cadr data))
    (define (singleton-map  data) (caddr data))
    (define (union-map      data) (cadddr data))
    (define (object-map     data) (car (cddddr data)))
    ;
    ; returning no arguments constructor
    ;
    (lambda () 
      (let ((data (list 'data 1 (dictionary) (dictionary) (dictionary))))   
        (((object-map data) 'insert!) 0 (zero 0)) ; zero added with 0 hash
        (this data)))))

; it is easy to miss this crucial line of code which initializes the
; static 'manager' member of the 'set' class. it needs to be called *after*
; the set-manager class has been properly defined. We face a similar problem
; in python, and of course in C or C++ (but those languages have forward
; declaration). Of course in many cases, this sort of issues goes away by
; reordering the code. However, this may not work in cases of mutual dependency
; between the two classes. It does make sense to define set-manager after set.

(set 'set-up-manager) 


; main
(define empty   (set 'zero))
(define one     ((set 'successor) empty))
(define two     ((set 'successor) one))
(define three   ((set 'successor) two))
(define four    ((set 'successor) three))
(define five    ((set 'successor) four))

(set 'debug)

(exit 0)




