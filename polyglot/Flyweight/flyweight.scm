; Flyweight Design Pattern

; The main idea of the flyweight design pattern is to store objects
; in a dictionary so they can be reused, rather than new objects be
; created. This pattern is particularly well suited to classes of 
; immutable objects which is the case we shall consider here. Because
; dictionaries cannot exist without keys, the flyweight design pattern
; is closely related to the question of hashing.
;
; We shall consider the example of an inductive type Set with the three
; constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
; Union : Set -> Set -> Set. The type Set therefore corresponds to 
; the free algebra generated by a single element 0 (the empty set) and
; the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
; (inclusion) and equivalence between sets are very important, we shall 
; not consider it here and simply look at elements of type Set as syntactic
; objects. A typical OOP implementation is based on the composite  design 
; pattern which we shall adopt in this example.
;
; Objects (which are immutable) are supposed to be reused, not created.
; So the constructors of the class Set (and its subclasses) should not
; be used directly. Instead, the class should provide static factory 
; functions for 0, {x} and xUy. However, these factory functions should 
; not be simple wrappers around class constructors and should instead 
; check whether an object has previously been created.
;
; Fundamentally, we need to maintain a dictionary of created objects and
; we shall design a separate class SetManager to handle this dictionary.
; In fact the factory functions 0, {x}, xUy will be delegated to the class
; SetManager and Set will simply pass on the client's requests for object
; retrieval (or construction) to SetManager via a static member embedded
; in the class Set. As objects are being created and stored into the 
; manager's dictionary, dynamic hash values will be generated and assigned 
; to objects. The handling of hash values will also be performed by SetManager.
;
; It is possible to consider static algorithms for hash values. However, 
; these often do not guarantee that two objects with equal hash are equal. 
; It is nice to know that a static hash function is a (mathematically) 
; injective mapping. In the case at hand, such function exist but are 
; computationally unusable due to their rapid growth. Using dynamic hashing, 
; although not specifically called for by the flyweight design pattern, 
; provides the convenience of producing truly unique hashes, which grow very 
; slowly (a hash counter is incremented at each object creation). 
;
; So this example illustrate a case of flyweight design pattern, as well
; as proposing a scheme for the generation of dynamic hash values. 


; standard composite pattern with abstract base class, and three concrete
; subclasses corresponding to each constructor of the inductive type Set

(define virtual-table   ; constructor
  (let ((let-for-name-encapsulation 'anything))
    ; object created from data is message passing interface
    (define (this data)
      (lambda (m)
        (cond ((eq? m 'to-string) (to-string data))
              ((eq? m 'zero?)     (is-zero? data))
              ((eq? m 'singleton?)(singleton? data))
              ((eq? m 'union?)    (union? data))
              ((eq? m 'element)   (element data))
              ((eq? m 'left)      (left data))
              ((eq? m 'right)     (right data))
              (else (error "set-virtual-table: unknown operation: " m)))))
    ;
    (define (to-string data)  (cadr data))
    (define (is-zero? data)   (caddr data))
    (define (singleton? data) (cadddr data))
    (define (union? data)     (car (cddddr data)))
    (define (element data)    (car (cdr (cddddr data))))
    (define (left data)       (car (cdr (cdr (cddddr data)))))
    (define (right data)      (car (cdr (cdr (cdr (cddddr data))))))
    ;
    ; returning 7 argument constructor
    ;
    (lambda(a1 a2 a3 a4 a5 a6 a7) (this (list 'data a1 a2 a3 a4 a5 a6 a7)))))


(define set-virtual-table
  (virtual-table
    (lambda (data) (error "set: to-string in not implemented"))
    (lambda (data) (error "set: zero? is not implemented"))
    (lambda (data) (error "set: singleton? is not implemented"))
    (lambda (data) (error "set: union? is not implemented"))
    (lambda (data) (error "set: element is not implemented"))
    (lambda (data) (error "set: left is not implemented"))
    (lambda (data) (error "set: right is not implemented"))))

(define zero-virtual-table
  (virtual-table
    (lambda (data) "0")
    (lambda (data) #t)
    (lambda (data) #f)
    (lambda (data) #f)
    (lambda (data) (error "zero: empty set has no element"))
    (lambda (data) (error "zero: left is not implemented"))
    (lambda (data) (error "zero: right is not implemented"))))

(define singleton-virtual-table
  (virtual-table
    (lambda (data) (string-append "{" ((caddr data) 'to-string) "}"))
    (lambda (data) #f)
    (lambda (data) #t)
    (lambda (data) #f)
    (lambda (data) (caddr data))
    (lambda (data) (error "singleton left is not implemented"))
    (lambda (data) (error "singleton right is not implemented"))))

(define union-virtual-table
  (virtual-table
    (lambda (data) 
      (string-append
        ((caddr data) 'to-string) "U" ((cadddr data) 'to-string)))
    (lambda (data) #f)
    (lambda (data) #f)
    (lambda (data) #t)
    (lambda (data) (error "union: element is not implemented"))
    (lambda (data) (caddr data))
    (lambda (data) (cadddr data))))


(define set   ; constructor
  (let ((let-for-name-encapsulation 'anything))
    ; object created from data is message passing interface
    (define (this data)
      (lambda (m)
        (cond ((eq? m 'hash-code) (hash-code data)) ; not-virtual
              ((eq? m 'to-string) (to-string data))
              ((eq? m 'zero?)     (is-zero? data))
              ((eq? m 'singleton?)(singleton? data))
              ((eq? m 'union?)    (union? data))
              ((eq? m 'element)   (element data))
              ((eq? m 'left)      (left data))
              ((eq? m 'right)     (right data))
              (else (error "set: unknown operation: " m)))))
    ;
    (define (hash-code data) (cadr data))
    (define (v-table data)   (caddr data))
    (define (to-string data) (((v-table data) 'to-string)









