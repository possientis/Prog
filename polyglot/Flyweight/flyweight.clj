; Flyweight Design Pattern
(ns flyweight (:gen-class))
; The main idea of the flyweight design pattern is to store objects
; in a dictionary so they can be reused, rather than new objects be
; created. This pattern is particularly well suited to classes of 
; immutable objects which is the case we shall consider here. Because
; dictionaries cannot exist without keys, the flyweight design pattern
; is closely related to the question of hashing.
;
; We shall consider the example of an inductive type Set with the three
; constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
; Union : Set -> Set -> Set. The type Set therefore corresponds to 
; the free algebra generated by a single element 0 (the empty set) and
; the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
; (inclusion) and equivalence between sets are very important, we shall 
; not consider it here and simply look at elements of type Set as syntactic
; objects. A typical OOP implementation is based on the composite  design 
; pattern which we shall adopt in this example.
;
; Objects (which are immutable) are supposed to be reused, not created.
; So the constructors of the class Set (and its subclasses) should not
; be used directly. Instead, the class should provide static factory 
; functions for 0, {x} and xUy. However, these factory functions should 
; not be simple wrappers around class constructors and should instead 
; check whether an object has previously been created.
;
; Fundamentally, we need to maintain a dictionary of created objects and
; we shall design a separate class SetManager to handle this dictionary.
; In fact the factory functions 0, {x}, xUy will be delegated to the class
; SetManager and Set will simply pass on the client's requests for object
; retrieval (or construction) to SetManager via a static member embedded
; in the class Set. As objects are being created and stored into the 
; manager's dictionary, dynamic hash values will be generated and assigned 
; to objects. The handling of hash values will also be performed by SetManager.
;
; It is possible to consider static algorithms for hash values. However, 
; these often do not guarantee that two objects with equal hash are equal. 
; It is nice to know that a static hash function is a (mathematically) 
; injective mapping. In the case at hand, such function exist but are 
; computationally unusable due to their rapid growth. Using dynamic hashing, 
; although not specifically called for by the flyweight design pattern, 
; provides the convenience of producing truly unique hashes, which grow very 
; slowly (a hash counter is incremented at each object creation). 
;
; So this example illustrate a case of flyweight design pattern, as well
; as proposing a scheme for the generation of dynamic hash values. 

(defmulti hash-code   :type)
(defmulti to-string   :type)
(defmulti is-zero?    :type)
(defmulti singleton?  :type)
(defmulti union?      :type)
(defmulti element     :type)
(defmulti left        :type)
(defmulti right       :type)

(defmethod hash-code  ::set [data] (:hash data))  ; actually not virtual

; set vitual table
(defmethod to-string  ::set [data] (throw (Exception. "Set: invalid operation"))) 
(defmethod is-zero?   ::set [data] (throw (Exception. "Set: invalid operation")))
(defmethod singleton? ::set [data] (throw (Exception. "Set: invalid operation")))
(defmethod union?     ::set [data] (throw (Exception. "Set: invalid operation")))
(defmethod element    ::set [data] (throw (Exception. "Set: invalid operation")))
(defmethod left       ::set [data] (throw (Exception. "Set: invalid operation")))
(defmethod right      ::set [data] (throw (Exception. "Set: invalid operation")))

; zero vitual table
(derive ::zero ::set)
(defmethod to-string  ::zero [data] "0") 
(defmethod is-zero?   ::zero [data] true)
(defmethod singleton? ::zero [data] false)
(defmethod union?     ::zero [data] false)
(defmethod element    ::zero [data] (throw (Exception. "Set: invalid operation")))
(defmethod left       ::zero [data] (throw (Exception. "Set: invalid operation")))
(defmethod right      ::zero [data] (throw (Exception. "Set: invalid operation")))

; singleton vitual table
(derive ::single ::set)
(defmethod to-string  ::single [data] (str "{" ((:element data):to-string) "}")) 
(defmethod is-zero?   ::single [data] false)
(defmethod singleton? ::single [data] true)
(defmethod union?     ::single [data] false)
(defmethod element    ::single [data] (:element data))
(defmethod left       ::single [data] (throw(Exception. "Set: invalid operation")))
(defmethod right      ::single [data] (throw(Exception. "Set: invalid operation")))

; union vitual table
(derive ::union ::set)
(defmethod to-string  ::union [data] 
  (str ((:left data):to-string) "U" ((:right data):to-string)))  
(defmethod is-zero?   ::union [data] false)
(defmethod singleton? ::union [data] false)
(defmethod union?     ::union [data] true)
(defmethod element    ::union [data] (throw(Exception. "Set: invalid operation")))
(defmethod left       ::union [data] (:left data))
(defmethod right      ::union [data] (:right data))


(declare SetManager)

(def Set        ; constructor
  (letfn
    ; object created from data is message passing interface
    [(this [data]
       (let [class-dictionary { :hash-code  hash-code
                                :to-string  to-string
                                :zero?      is-zero?
                                :singleton? singleton?
                                :union?     union?
                                :element    element
                                :left       left
                                :right      right     }]
         (fn [m]
           (let [operation (class-dictionary m :notfound)]
             (if (= operation :notfound)
               (throw (new Exception (format "Set: unknown operation %s" m)))
               (operation data))))))]
    ;
    ; static data
    ;
    (let [manager           (ref nil) ; initialized later with SetManager
          set-up-manager    (fn [] (dosync (ref-set manager (SetManager))))
          zero              (fn [] ( manager :zero))
          singleton         (fn [] (fn [x]   ((manager :singleton) x)))
          union             (fn [] (fn [x y] ((manager :union) x y)))
          successor         (fn [] (fn [x]  ((Set :union) x ((Set :singleton) x))))
          debug             (fn []    ( manager :debug))
          static-dictionary { :set-up-manager set-up-manager
                              :zero           zero
                              :singleton      singleton
                              :union          union
                              :successor      successor
                              :debug          debug }
          static-interface (fn [m]
                             (let [operation (static-dictionary m :notfound)]
                               (if (= operation :notfound)
                                 (this m)         ; returning object instance
                                 (operation))))]  ; or static method
      ;
      ; returning interface
      ;
      static-interface)))


(def Zero       ; constructor
  ; returning single argument constructor
  (fn [hash-value]
    (let [data {:type ::zero :hash hash-value}]
      (Set data))))

(def Singleton  ; constuctor
  ; returning two arguments contructor
  (fn [x hash-value]
    (let [data {:type ::single :hash hash-value :element x}]
      (Set data))))

(def Union      ; constructor
  ; returning three arguments constructor
  (fn [x y hash-value]
    (let [data {:type ::union :hash hash-value :left x :right y}]
      (Set data))))

; The manager maintains various dictionaries. The main dictionary is objectMap,
; which given a hash code, returns a previously constructed object. However,
; The manager needs to implement the factory methods corresponding to the 
; three constructors of the inductive type Set. Implementing the zero()
; method is easy. The manager always assigns 0 as its hash code and creates
; a single object which is stored once and for all in the objectMap dictionary.
; The method zero() simply returns a reference to the existing object.
; In order to implement singleton(x) (returning the object {x} from x), the 
; manager needs to quickly establish whether (given the set x and its hash code)
; the set {x} has already been created. However, the manager cannot simply query
; the objectMap dictionary because it does not know what dynamic hash code the
; singleton {x} was assigned (assuming it already exists). This is why the 
; manager maintains an additional dictionary 'singletonMap' which stores the 
; hash code of {x} given the hash code of x. Hence by querying the dictionary 
; singletonMap, the manager is able to establish whether {x} already exists, 
; and if so, what its hash code is. Given the hash code of {x} it can simply 
; query objectMap and return the appropriate object. In the case when the object
; {x} does not already exist, the manager assigns the current value of 
; 'nextHash' to the object {x}, then creates the object using this hash value, 
; and before it returns the object, the manager updates objectMap with the new 
; object and singletonMap with the link between the hash of x and that of {x}. 
; In order to implement the factory method union(x,y), a similar scheme is 
; adopted which requires a new dictionary unionMap. This map could have been 
; implemented with pairs as keys, but we decided to keep using integers, and 
; simply map pairs of ints to ints with the Cantor function.

(declare set-manager-zero)
(declare set-manager-singleton)
(declare set-manager-union)
(declare set-manager-debug)

(def SetManager ; constructor
  (letfn
    ; the object created from data is a message passing interface
    [(this [data]
       (let [class-dictionary { :zero       set-manager-zero 
                                :singleton  set-manager-singleton
                                :union      set-manager-union
                                :debug      set-manager-debug }]
         (fn [m]
           (let [operation (class-dictionary m :notfound)]
             (if (= operation :notfound)
               (throw (Exception. (format "SetManager: unknown operation %s")))
               (operation data))))))]
    ;
    ; returning no argument constructor
    ;
    (fn [] (this {  :next-hash      (ref 1)
                    :singleton-map  (ref {})
                    :union-map      (ref {})
                    :object-map     (ref {0 (Zero 0)})  }))))



(defn pairing-cantor [x y] (+ y (quot (* (+ x y 1) (+ x y)) 2)))

(defn set-manager-zero [data] ((deref (:object-map data)) 0))

(defn set-manager-singleton [data]
  (fn [x]
    (dosync
      (let [next-hash     (:next-hash data)
            singleton-map (:singleton-map data)
            object-map    (:object-map data)
            hash-x        (x :hash-code)
            mapped-hash   (@singleton-map hash-x :notfound)]  ; does {x} exist?
        (if (= :notfound mapped-hash)                         ; {x} is unknown 
          (do
            (alter singleton-map assoc hash-x @next-hash)     ; {x} -> next-hash
            (let [object (Singleton x @next-hash)]            ; creating {x}
              (alter object-map assoc @next-hash object)      ; saving {x}
              (alter next-hash inc)                           ; next-hash++
              object))                                        ; returning {x}
          (@object-map mapped-hash))))))                      ; {x} known

(defn set-manager-union [data]
  (fn [x y]
    (dosync
      (let [next-hash     (:next-hash data)
            union-map     (:union-map data)
            object-map    (:object-map data)
            hash-x        (x :hash-code)
            hash-y        (y :hash-code)
            hash-xy       (pairing-cantor hash-x hash-y)
            mapped-hash   (@union-map hash-xy :notfound)]     ; does xUy exist
        (if (= :notfound mapped-hash)                         ; xUy is unknown
          (do
            (alter union-map assoc hash-xy @next-hash)        ; xUy -> next-hash
            (let [object (Union x y @next-hash)]              ; creating xUy
              (alter object-map assoc @next-hash object)      ; saving xUy
              (alter next-hash inc)                           ; next-hash++
              object))                                        ; returning xUy
          (@object-map mapped-hash))))))                      ; xUy known

(defn set-manager-debug [data]
  (let [next-hash   @(:next-hash data)
        object-map  @(:object-map data)]
    (loop [i 0]
      (if (< i next-hash)
        (do
          (println "hash =" i ":" ((object-map i):to-string))
          (recur (+ i 1))))))) 


(Set :set-up-manager)                  

(defn -main []
  (def zero   (Set :zero))
  (def one    ((Set :successor) zero))
  (def two    ((Set :successor) one))
  (def three  ((Set :successor) two))
  (def four   ((Set :successor) three))
  (def five   ((Set :successor) four))

  (Set :debug))

;(-main)












