// Flyweight Design Pattern
using System;
using System.Collections.Generic;

// The main idea of the flyweight design pattern is to store objects
// in a dictionary so they can be reused, rather than new objects be
// created. This pattern is particularly well suited to classes of 
// immutable objects which is the case we shall consider here. Because
// dictionaries cannot exist without keys, the flyweight design pattern
// is closely related to the question of hashing.
//
// We shall consider the example of an inductive type Set with the three
// constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
// Union : Set -> Set -> Set. The type Set therefore corresponds to 
// the free algebra generated by a single element 0 (the empty set) and
// the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
// (inclusion) and equivalence between sets are very important, we shall 
// not consider it here and simply look at elements of type Set as syntactic
// objects. A typical OOP implementation is based on the composite  design 
// pattern which we shall adopt in this example.
//
// Objects (which are immutable) are supposed to be reused, not created.
// So the constructors of the class Set (and its subclasses) should not
// be used directly. Instead, the class should provide static factory 
// functions for 0, {x} and xUy. However, these factory functions should 
// not be simple wrappers around class constructors and should instead 
// check whether an object has previously been created.
//
// Fundamentally, we need to maintain a dictionary of created objects and
// we shall design a separate class SetManager to handle this dictionary.
// In fact the factory functions 0, {x}, xUy will be delegated to the class
// SetManager and Set will simply pass on the client's requests for object
// retrieval (or construction) to SetManager via a static member embedded
// in the class Set. As objects are being created and stored into the 
// manager's dictionary, dynamic hash values will be generated and assigned 
// to objects. The handling of hash values will also be performed by SetManager.
//
// It is possible to consider static algorithms for hash values. However, 
// these often do not guarantee that two objects with equal hash are equal. 
// It is nice to know that a static hash function is a (mathematically) 
// injective mapping. In the case at hand, such function exist but are 
// computationally unusable due to their rapid growth. Using dynamic hashing, 
// although not specifically called for by the flyweight design pattern, 
// provides the convenience of producing truly unique hashes, which grow very 
// slowly (a hash counter is incremented at each object creation). 
//
// So this example illustrate a case of flyweight design pattern, as well
// as proposing a scheme for the generation of dynamic hash values. 


// standard composite pattern with abstract base class, and three concrete
// subclasses corresponding to each constructor of the inductive type Set
abstract class Set {
  // Additionally to composite pattern, we include a static manager
  // whose role is threefold: (i) serve as factory object (ii) maintain
  // dictionaty of existing object and (iii) handle dynamic hash generation
  private static readonly SetManager manager = new SetManager();
  // Additionally to composite pattern, each object maintains an immutable
  // hash code whose value is determined at runtime by the manager at creation. 
  private readonly int hash;
  protected Set(int hash)               { this.hash = hash; }
  public override int GetHashCode()     { return hash; }
  // The inductive type provides an interface of static factory methods 
  // which corresponds to the type constructors. However, contrary to standard
  // composite pattern, these factory methods actually delegate the work
  // of object creation of the manager
  public static Set Zero()              { return manager.Zero(); }
  public static Set Singleton(Set x)    { return manager.Singleton(x); }
  public static Set Union(Set x, Set y) { return manager.Union(x, y); }
  // convenience function
  public static Set Successor(Set x)    { return Union(x, Singleton(x)); }
  // implemented by subclasses
  public abstract override string ToString();
  public abstract bool IsZero();
  public abstract bool IsSingleton();
  public abstract bool IsUnion();
  public abstract Set element();
  public abstract Set left();
  public abstract Set right();
  // debug
  public static void Debug(){ manager.Debug(); }
}

class Zero : Set {
  public Zero(int hash)                : base(hash){}
  public override String ToString()    { return "0"; }
  public override bool IsZero()        { return true; }
  public override bool IsSingleton()   { return false; }
  public override bool IsUnion()       { return false; }
  public override Set element() { throw new InvalidOperationException(); }
  public override Set left()    { throw new InvalidOperationException(); }
  public override Set right()   { throw new InvalidOperationException(); }
}

class Singleton : Set {
  private readonly Set _element;
  public Singleton(Set x, int hash)     : base(hash){ this._element = x; }
  public override String ToString()     { return "{" + _element + "}"; }
  public override bool IsZero()         { return false; }
  public override bool IsSingleton()    { return true; }
  public override bool IsUnion()        { return false; }
  public override Set element()         { return _element; }
  public override Set left()    { throw new InvalidOperationException(); }
  public override Set right()   { throw new InvalidOperationException(); }
}

class Union : Set {
  private readonly Set _left;
  private readonly Set _right;
  public Union(Set x, Set y, int hash)    : base(hash){ 
    this._left = x; this._right = y; }
  public override String ToString()       { return _left + "U" + _right; }
  public override bool IsZero()           { return false; }
  public override bool IsSingleton()      { return false; }
  public override bool IsUnion()          { return true; }
  public override Set left()              { return _left; }
  public override Set right()             { return _right; }
  public override Set element() { throw new InvalidOperationException(); }
}

class SetManager {
  // The manager maintains various dictionaries. The main dictionary is objectMap,
  // which given a hash code, returns a previously constructed object. However,
  // The manager needs to implement the factory methods corresponding to the 
  // three constructors of the inductive type Set. Implementing the zero()
  // method is easy. The manager always assigns 0 as its hash code and creates
  // a single object which is stored once and for all in the objectMap dictionary.
  // The method zero() simply returns a reference to the existing object.
  // In order to implement singleton(x) (returning the object {x} from x), the 
  // manager needs to quickly establish whether (given the set x and its hash code)
  // the set {x} has already been created. However, the manager cannot simply query
  // the objectMap dictionary because it does not know what dynamic hash code the
  // singleton {x} was assigned (assuming it already exists). This is why the 
  // manager maintains an additional dictionary 'singletonMap' which stores the 
  // hash code of {x} given the hash code of x. Hence by querying the dictionary 
  // singletonMap, the manager is able to establish whether {x} already exists, 
  // and if so, what its hash code is. Given the hash code of {x} it can simply 
  // query objectMap and return the appropriate object. In the case when the object
  // {x} does not already exist, the manager assigns the current value of 
  // 'nextHash' to the object {x}, then creates the object using this hash value, 
  // and before it returns the object, the manager updates objectMap with the new 
  // object and singletonMap with the link between the hash of x and that of {x}. 
  // In order to implement the factory method union(x,y), a similar scheme is 
  // adopted which requires a new dictionary unionMap. This map could have been 
  // implemented with pairs as keys, but we decided to keep using integers, and 
  // simply map pairs of ints to ints with the Cantor function.

  private int nextHash = 1; // next hash value of whichever object is created
  private readonly Dictionary<int,int> singletonMap = new Dictionary<int,int>();
  private readonly Dictionary<int,int> unionMap     = new Dictionary<int,int>();
  private readonly Dictionary<int,Set> objectMap    = new Dictionary<int,Set>();

  public SetManager(){ objectMap[0] = new Zero(0); }

  public Set Zero()               { return objectMap[0]; }
  public Set Singleton(Set x){
    int hash = x.GetHashCode();
    int mappedHash;
    bool found = singletonMap.TryGetValue(hash, out mappedHash); // {x} exists?
    if(!found){                             // singleton {x} is unknown
      singletonMap[hash] = nextHash;        // nextHash allocated to {x}
      Set set = new Singleton(x, nextHash); // creating {x}
      objectMap[nextHash] = set;            // saving {x} for future reference
      nextHash++;                           // for future hash allocation
      return set;
    } else {                                // singleton {x} is known
      return objectMap[mappedHash];         // simply retrieve object from hash
    }
  }

  public Set Union(Set x, Set y)  {
    int hx = x.GetHashCode();
    int hy = y.GetHashCode();
    int hash = pairingCantor(hx, hy);
    int mappedHash;
    bool found = unionMap.TryGetValue(hash, out mappedHash);  // xUy exists?
    if(!found){                             // union xUy is unknown
      unionMap[hash] = nextHash;            // nextHash allocated to xUy
      Set set = new Union(x, y, nextHash);  // creating xUy
      objectMap[nextHash] = set;            // saving xUy for future reference
      nextHash++;                           // for future hash allocation
      return set;
    } else {                                // union xUy is known
      return objectMap[mappedHash];         // simply retrieve object from hash
    }
  }


  public void Debug() {
    for(int i = 0; i < nextHash; ++i){
      Console.WriteLine("hash = " + i + ": " + objectMap[i]);
    }
  }
  public static int pairingCantor(int x, int y){
    return (x + y + 1)*(x + y)/2 + y; // '/' is integer division
  }
}

public class Flyweight {
  public static void Main(string[] args){
    Set zero  = Set.Zero();
    Set one   = Set.Successor(zero);
    Set two   = Set.Successor(one);
    Set three = Set.Successor(two);
    Set four  = Set.Successor(three);
    Set.Successor(four);  // do not need to define 'five'. no compiler warning
    Set.Debug();
  }
}
