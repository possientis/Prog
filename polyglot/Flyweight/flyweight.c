// Flyweight Design Pattern
#include "dict.h" // Dictionary
#include <malloc.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>

// The main idea of the flyweight design pattern is to store objects
// in a dictionary so they can be reused, rather than new objects be
// created. This pattern is particularly well suited to classes of 
// immutable objects which is the case we shall consider here. Because
// dictionaries cannot exist without keys, the flyweight design pattern
// is closely related to the question of hashing.
//
// We shall consider the example of an inductive type Set with the three
// constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
// Union : Set -> Set -> Set. The type Set therefore corresponds to 
// the free algebra generated by a single element 0 (the empty set) and
// the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
// (inclusion) and equivalence between sets are very important, we shall 
// not consider it here and simply look at elements of type Set as syntactic
// objects. A typical OOP implementation is based on the composite  design 
// pattern which we shall adopt in this example.
//
// Objects (which are immutable) are supposed to be reused, not created.
// So the constructors of the class Set (and its subclasses) should not
// be used directly. Instead, the class should provide static factory 
// functions for 0, {x} and xUy. However, these factory functions should 
// not be simple wrappers around class constructors and should instead 
// check whether an object has previously been created.
//
// Fundamentally, we need to maintain a dictionary of created objects and
// we shall design a separate class SetManager to handle this dictionary.
// In fact the factory functions 0, {x}, xUy will be delegated to the class
// SetManager and Set will simply pass on the client's requests for object
// retrieval (or construction) to SetManager via a static member embedded
// in the class Set. As objects are being created and stored into the 
// manager's dictionary, dynamic hash values will be generated and assigned 
// to objects. The handling of hash values will also be performed by SetManager.
//
// It is possible to consider static algorithms for hash values. However, 
// these often do not guarantee that two objects with equal hash are equal. 
// It is nice to know that a static hash function is a (mathematically) 
// injective mapping. In the case at hand, such function exist but are 
// computationally unusable due to their rapid growth. Using dynamic 
// hashing, although not specifically called for by the flyweight design 
// pattern, provides the convenience of producing truly unique hashes, which 
// grow very slowly (a hash counter is incremented at each object creation). 
//
// So this example illustrate a case of flyweight design pattern, as well
// as proposing a scheme for the generation of dynamic hash values. 

typedef struct SetvTable_   SetvTable;
typedef struct Set_         Set;
typedef struct Zero_        Zero;
typedef struct Singleton_   Singleton;
typedef struct Union_       Union;
typedef struct SetManager_  SetManager;

/******************************************************************************/
/*                           SetvTable class                                  */
/******************************************************************************/

struct SetvTable_ {
  int   refcount;
  void  (*delete)       (Set* self); // virtual destructor
  void  (*toString)     (Set* self, char* bufffer, size_t size);
  int   (*isZero)       (Set* self);
  int   (*isSingleton)  (Set* self);
  int   (*isUnion)      (Set* self);
  Set*  (*element)      (Set* self);
  Set*  (*left)         (Set* self);
  Set*  (*right)        (Set* self);
};


/******************************************************************************/
/*                                  Set class                                 */
/******************************************************************************/
struct Set_ {
  int         refcount;
  int         hash;
  SetvTable*  vTable;
};

Set* Set_new(int hash){
  // TBI
}
Set* Set_copy(Set* self){
  // TBI
}

Set* Set_delete(Set* self){
  // TBI
}

// not a virtual method
int Set_hashCode(Set* self){
  assert(self != NULL);
  return self->hash;
}

// static method
SetManager* Set_manager(){
  // TBI
}

// static method
Set* Set_zero(){
  // TBI
}

// static method
Set* Set_singleton(Set* x){
  // TBI
}

// static method
Set* Set_union(Set* x, Set* y){
  // TBI
}

// static method
Set* Set_successor(Set* x){
  // TBI (details of memory semantics)
  assert(x != NULL);
  return Set_union(x, Set_singleton(x));
}

// static method
void Set_debug(){
  // TBI
}


/******************************************************************************/
/*                                 Zero class                                 */
/******************************************************************************/

struct Zero_ {
  Set   base;
};

// override
void Zero_toString(Zero* self, char* buffer, size_t size){
  assert(self != NULL);
  assert(size > 2);
  strcpy(buffer, "0");
}

// override
int Zero_isZero(Zero* self){
  assert(self != NULL);
  return 1;   // true
}

// override
int Zero_isSingleton(Zero* self){
  assert(self != NULL);
  return 0;   // false
}

// override
int Zero_isUnion(Zero* self){
  assert(self != NULL);
  return 0;   // false
}


// override
Set* Zero_element(Zero* self){
  assert(self != NULL);
  fprintf(stderr, "Zero: illegal call to element method\n");
  assert(NULL);
  return NULL;
} 

// override
Set* Zero_left(Zero* self){
  assert(self != NULL);
  fprintf(stderr, "Zero: illegal call to left method\n");
  assert(NULL);
  return NULL;
}

// override
Set* Zero_right(Zero* self){
  assert(self != NULL);
  fprintf(stderr, "Zero: illegal call to right method\n");
  assert(NULL);
  return NULL;
}


void Zero_delete(Zero* self){
  assert(self != NULL);
  Set* base = (Set*) self;
  assert(base->refcount > 0);
  base->refcount--;
  if(base->refcount == 0){
//    SetManager_deallocate_zero(self);
  }
}



/******************************************************************************/
/*                              Singleton class                               */
/******************************************************************************/


/******************************************************************************/
/*                                 Union class                                */
/******************************************************************************/


/******************************************************************************/
/*                             SetManager class                               */
/******************************************************************************/



/******************************************************************************/
/*                             vTable initializers                            */
/******************************************************************************/

void _Zero_toString(Set* self, char* buffer, size_t size){
  assert(self != NULL);
  Zero_toString((Zero*) self, buffer, size); // downcast
}

int _Zero_isZero(Set* self){
  assert(self != NULL);
  return Zero_isZero((Zero*) self);          // downcast
}

int _Zero_isSingleton(Set* self){
  assert(self != NULL);
  return Zero_isSingleton((Zero*) self);     // downcast
}

int _Zero_isUnion(Set* self){
  assert(self != NULL);
  return Zero_isUnion((Zero*) self);         // downcast
}


Set* _Zero_element(Set* self){
  assert(self != NULL);
  return Zero_element((Zero*) self);         // downcast
} 

Set* _Zero_left(Set* self){
  assert(self != NULL);
  return Zero_left((Zero*) self);            // downcast
}

Set* _Zero_right(Set* self){
  assert(self != NULL);
  return Zero_right((Zero*) self);           // downcast
}


void _Zero_vTable_initialize(SetvTable* vTable){
  assert(vTable != NULL);

  
}

int main(){

  return 0;
}
