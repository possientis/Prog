# Flyweight Design Pattern

# The main idea of the flyweight design pattern is to store objects
# in a dictionary so they can be reused, rather than new objects be
# created. This pattern is particularly well suited to classes of 
# immutable objects which is the case we shall consider here. Because
# dictionaries cannot exist without keys, the flyweight design pattern
# is closely related to the question of hashing.
#
# We shall consider the example of an inductive type Set with the three
# constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
# Union : Set -> Set -> Set. The type Set therefore corresponds to 
# the free algebra generated by a single element 0 (the empty set) and
# the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
# (inclusion) and equivalence between sets are very important, we shall 
# not consider it here and simply look at elements of type Set as syntactic
# objects. A typical OOP implementation is based on the composite  design 
# pattern which we shall adopt in this example.
#
# Objects (which are immutable) are supposed to be reused, not created.
# So the constructors of the class Set (and its subclasses) should not
# be used directly. Instead, the class should provide static factory 
# functions for 0, {x} and xUy. However, these factory functions should 
# not be simple wrappers around class constructors and should instead 
# check whether an object has previously been created.
#
# Fundamentally, we need to maintain a dictionary of created objects and
# we shall design a separate class SetManager to handle this dictionary.
# In fact the factory functions 0, {x}, xUy will be delegated to the class
# SetManager and Set will simply pass on the client's requests for object
# retrieval (or construction) to SetManager via a static member embedded
# in the class Set. As objects are being created and stored into the 
# manager's dictionary, dynamic hash values will be generated and assigned 
# to objects. The handling of hash values will also be performed by SetManager.
#
# It is possible to consider static algorithms for hash values. However, 
# these often do not guarantee that two objects with equal hash are equal. 
# It is nice to know that a static hash function is a (mathematically) 
# injective mapping. In the case at hand, such function exist but are 
# computationally unusable due to their rapid growth. Using dynamic hashing, 
# although not specifically called for by the flyweight design pattern, 
# provides the convenience of producing truly unique hashes, which grow very 
# slowly (a hash counter is incremented at each object creation). 
#
# So this example illustrate a case of flyweight design pattern, as well
# as proposing a scheme for the generation of dynamic hash values. 

# standard composite pattern with abstract base class, and three concrete
# subclasses corresponding to each constructor of the inductive type Set
class Set:
    # Additionally to composite pattern, we include a static manager
    # whose role is threefold: (i) serve as factory object (ii) maintain
    # dictionaty of existing object and (iii) handle dynamic hash generation
    _manager = None # will be properly defined after SetManager class
    # Additionally to composite the pattern, each object maintains an immutable
    # hash code whose value is determined at runtime by the manager at creation. 
    def __init__(self, hashCode):   self._hash = hashCode
    def __hash__(self):             return self._hash
    # The inductive type provides an interface of static factory methods 
    # which corresponds to the type constructors. However, contrary to standard
    # composite pattern, these factory methods actually delegate the work
    # of object creation of the manager
    def zero():             return Set._manager.zero()
    def singleton(x):       return Set._manager.singleton(x)
    def union(x,y):         return Set._manager.union(x,y)
    # convenience function
    def successor(x):       return Set.union(x, Set.singleton(x))
    # implemented by subclasses
    def __str__(self):      raise NotImplementedError
    def isZero(self):       raise NotImplementedError
    def isSingletong(self): raise NotImplementedError
    def isUnion(self):      raise NotImplementedError
    def element(self):      raise NotImplementedError
    def left(self):         raise NotImplementedError
    def right(self):        raise NotImplementedError
    # debug
    def debug():            Set._manager.debug()

class Zero(Set):
    def __init__(self, hashCode): Set.__init__(self, hashCode)
    def __str__(self):      return "0"
    def isZero(self):       return True
    def isSingletong(self): return False
    def isUnion(self):      return False
    def element(self):      raise Exception("The empty set has no element")
    def left(self):         raise Exception("The empty set has no left subset")
    def right(self):        raise Exception("The empty set has no right subset")
 
class Singleton(Set):
    def __init__(self, x, hashCode): 
        Set.__init__(self, hashCode)
        self._element = x
    def __str__(self):      return "{" + str(self._element) + "}"
    def isZero(self):       return False
    def isSingletong(self): return True
    def isUnion(self):      return False
    def element(self):      return self._element
    def left(self):         raise NotImplementedError
    def right(self):        raise NotImplementedError

class Union(Set):
    def __init__(self, x, y, hashCode): 
        Set.__init__(self, hashCode)
        self._left  = x
        self._right = y
    def __str__(self):      return str(self._left) + "U" + str(self._right)
    def isZero(self):       return False
    def isSingletong(self): return False
    def isUnion(self):      return True
    def left(self):         return self._left
    def right(self):        return self._right
    def element(self):      raise NotImplementedError


class SetManager:
    # The manager maintains various dictionaries. The main dictionary is objectMap,
    # which given a hash code, returns a previously constructed object. However,
    # The manager needs to implement the factory methods corresponding to the 
    # three constructors of the inductive type Set. Implementing the zero()
    # method is easy. The manager always assigns 0 as its hash code and creates
    # a single object which is stored once and for all in the objectMap dictionary.
    # The method zero() simply returns a reference to the existing object. In order
    # to implement singleton(x) (returning the object {x} from x), the manager 
    # needs to quickly establish whether (given the set x and its hash code) the 
    # set {x} has already been created. However, the manager cannot simply query
    # the objectMap dictionary because it does not know what dynamic hash code the
    # singleton {x} was assigned (assuming it already exists). This is why the 
    # manager maintains an additional dictionary 'singletonMap' which stores the 
    # hash code of {x} given the hash code of x. Hence by querying the dictionary 
    # singletonMap, the manager is able to establish whether {x} already exists, 
    # and if so, what its hash code is. Given the hash code of {x} it can simply 
    # query objectMap and return the appropriate object.In the case when the object
    # {x} does not already exist, the manager assigns the current value of 
    # 'nextHash' to the object {x}, then creates the object using this hash value, 
    # and before it returns the object, the manager updates objectMap with the new 
    # object and singletonMap with the link between the hash of x and that of {x}. 
    # In order to implement the factory method union(x,y), a similar scheme is 
    # adopted which requires a new dictionary unionMap. This map could have been 
    # implemented with pairs as keys, but we decided to keep using integers, and 
    # simply map pairs of ints to ints with the Cantor function.

    def pairingCantor(x,y): return (x + y + 1)*(x + y)//2 + y # '//' is integer div

    def __init__(self):
        self._nextHash      = 1  # next hash value of whichever object is created
        self._singletonMap  = {}
        self._unionMap      = {}
        self._objectMap     = {0:Zero(0)}

    def zero(self):         return self._objectMap[0]

    def singleton(self,x):
        hx = hash(x)
        mappedHash = self._singletonMap.get(hx)         # does {x} exist?
        if mappedHash == None:                          # singleton {x} is unknown
            self._singletonMap[hx] = self._nextHash     # nextHash allocated to {x}
            singleton = Singleton(x,self._nextHash)     # creating {x}
            self._objectMap[self._nextHash] = singleton # saving {x} for future ref
            self._nextHash += 1                         # for future hash alloc
            return singleton
        else:                                           # singleton {x} is known
            return self._objectMap[mappedHash]          # retrieving from hash
    
    def union(self,x,y):
        hx = hash(x)
        hy = hash(y)
        h = SetManager.pairingCantor(hx,hy)
        mappedHash = self._unionMap.get(h)              # does xUy exist?
        if mappedHash == None:                          # union xUy is unknown
            self._unionMap[h] = self._nextHash          # nextHash allocated to xUy
            union = Union(x,y,self._nextHash)           # creating xUy
            self._objectMap[self._nextHash] = union     # saving xUy for future ref
            self._nextHash += 1                         # for future hash alloc
            return union
        else:                                           # union xUy is known
            return self._objectMap[mappedHash]          # retrieving from hash

    def debug(self):
        for i in range(0,self._nextHash):
            print("hash = " + str(i) + ": " + str(self._objectMap[i]))

# final set up for class Set
Set._manager = SetManager()
    




zero    = Set.zero()
one     = Set.successor(zero) 
two     = Set.successor(one) 
three   = Set.successor(two) 
four    = Set.successor(three) 
five    = Set.successor(four) 

Set.debug()


