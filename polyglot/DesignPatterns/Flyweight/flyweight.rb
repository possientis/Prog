# Flyweight Design Pattern

# The main idea of the flyweight design pattern is to store objects
# in a dictionary so they can be reused, rather than new objects be
# created. This pattern is particularly well suited to classes of 
# immutable objects which is the case we shall consider here. Because
# dictionaries cannot exist without keys, the flyweight design pattern
# is closely related to the question of hashing.
#
# We shall consider the example of an inductive type Set with the three
# constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
# Union : Set -> Set -> Set. The type Set therefore corresponds to 
# the free algebra generated by a single element 0 (the empty set) and
# the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
# (inclusion) and equivalence between sets are very important, we shall 
# not consider it here and simply look at elements of type Set as syntactic
# objects. A typical OOP implementation is based on the composite  design 
# pattern which we shall adopt in this example.
#
# Objects (which are immutable) are supposed to be reused, not created.
# So the constructors of the class Set (and its subclasses) should not
# be used directly. Instead, the class should provide static factory 
# functions for 0, {x} and xUy. However, these factory functions should 
# not be simple wrappers around class constructors and should instead 
# check whether an object has previously been created.
#
# Fundamentally, we need to maintain a dictionary of created objects and
# we shall design a separate class SetManager to handle this dictionary.
# In fact the factory functions 0, {x}, xUy will be delegated to the class
# SetManager and Set will simply pass on the client's requests for object
# retrieval (or construction) to SetManager via a static member embedded
# in the class Set. As objects are being created and stored into the 
# manager's dictionary, dynamic hash values will be generated and assigned 
# to objects. The handling of hash values will also be performed by SetManager.
#
# It is possible to consider static algorithms for hash values. However, 
# these often do not guarantee that two objects with equal hash are equal. 
# It is nice to know that a static hash function is a (mathematically) 
# injective mapping. In the case at hand, such function exist but are 
# computationally unusable due to their rapid growth. Using dynamic hashing, 
# although not specifically called for by the flyweight design pattern, 
# provides the convenience of producing truly unique hashes, which grow very 
# slowly (a hash counter is incremented at each object creation). 
#
# So this example illustrate a case of flyweight design pattern, as well
# as proposing a scheme for the generation of dynamic hash values. 


# standard composite pattern with abstract base class, and three concrete
# subclasses corresponding to each constructor of the inductive type Set

class Set
  attr_reader :hash
  # Additionally to composite pattern, we include a static manager
  # whose role is threefold: (i) serve as factory object (ii) maintain
  # dictionaty of existing object and (iii) handle dynamic hash generation
  @@manager = nil # to be initialized later with constructor of SetManager 
  def self.setupManager()   @@manager = SetManager.new              end
  # Additionally to the composite pattern, each object maintains an immutable
  # hash code whose value is determined at runtime by the manager at creation. 
  def initialize(hash)      @hash = hash                            end 
  # The inductive type provides an interface of static factory methods 
  # which corresponds to the type constructors. However, contrary to standard
  # composite pattern, these factory methods actually delegate the work
  # of object creation of the manager
  def self.zero()           return @@manager.zero()                 end
  def self.singleton(x)     return @@manager.singleton(x)           end
  def self.union(x,y)       return @@manager.union(x,y)             end
  def self.successor(x)     return Set.union(x, Set.singleton(x))   end
  def self.debug()          @@manager.debug                         end
  # implemented by subclasses
  def to_s()                raise NotImplementedError.new           end
  def isZero()              raise NotImplementedError.new           end
  def isSingleton()         raise NotImplementedError.new           end
  def isZero()              raise NotImplementedError.new           end
  def element()             raise NotImplementedError.new           end
  def left()                raise NotImplementedError.new           end
  def right()               raise NotImplementedError.new           end
end

class Zero < Set
  def initialize(hash)      super(hash)                             end
  def to_s()                return "0"                              end
  def isZero()              return true                             end
  def isSingleton()         return false                            end
  def isUnion()             return false                            end
  def element()             raise NoMethodError.new                 end
  def left()                raise NoMethodError.new                 end
  def right()               raise NoMethodError.new                 end
end

class Singleton < Set
  attr_reader :element
  def initialize(x, hash)   super(hash); @element = x               end
  def to_s()                return "{#@element}"                    end
  def isZero()              return false                            end
  def isSingleton()         return true                             end
  def isUnion()             return false                            end
  # no need to define 'element'
  def left()                raise NoMethodError.new                 end
  def right()               raise NoMethodError.new                 end
end

class Union < Set
  attr_reader :left, :right
  def initialize(x,y,hash)  super(hash); @left = x; @right = y      end
  def to_s()                return "#{@left}U#{@right}"             end
  def isZero()              return false                            end
  def isSingleton()         return false                            end
  def isUnion()             return true                             end
  def element()             raise NoMethodError.new                 end
  # no need to define 'left' and 'right'
end





class SetManager
  # The manager maintains various dictionaries. The main dictionary is objectMap,
  # which given a hash code, returns a previously constructed object. However,
  # The manager needs to implement the factory methods corresponding to the 
  # three constructors of the inductive type Set. Implementing the zero()
  # method is easy. The manager always assigns 0 as its hash code and creates
  # a single object which is stored once and for all in the objectMap dictionary.
  # The method zero() simply returns a reference to the existing object. In order
  # to implement singleton(x) (returning the object {x} from x), the manager 
  # needs to quickly establish whether (given the set x and its hash code) the 
  # set {x} has already been created. However, the manager cannot simply query
  # the objectMap dictionary because it does not know what dynamic hash code the
  # singleton {x} was assigned (assuming it already exists). This is why the 
  # manager maintains an additional dictionary 'singletonMap' which stores the 
  # hash code of {x} given the hash code of x. Hence by querying the dictionary 
  # singletonMap, the manager is able to establish whether {x} already exists, 
  # and if so, what its hash code is. Given the hash code of {x} it can simply 
  # query objectMap and return the appropriate object.In the case when the object
  # {x} does not already exist, the manager assigns the current value of 
  # 'nextHash' to the object {x}, then creates the object using this hash value, 
  # and before it returns the object, the manager updates objectMap with the new 
  # object and singletonMap with the link between the hash of x and that of {x}. 
  # In order to implement the factory method union(x,y), a similar scheme is 
  # adopted which requires a new dictionary unionMap. This map could have been 
  # implemented with pairs as keys, but we decided to keep using integers, and 
  # simply map pairs of ints to ints with the Cantor function.

  def self.pairingCantor(x,y) return (x + y + 1)*(x + y)/2 + y end

  def initialize()
    @nextHash = 1
    @singletonMap = {}
    @unionMap = {}
    @objectMap = {0 => Zero.new(0)}
  end

  def zero()
    return @objectMap[0]
  end

  def singleton(x)
    hash = x.hash
    mappedHash = @singletonMap[hash]        # does {x} exist?
    if mappedHash == nil  then              # singleton {x} is unknown
      @singletonMap[hash] = @nextHash       # nextHash allocated to {x}
      object = Singleton.new(x, @nextHash)  # creating {x}
      @objectMap[@nextHash] = object        # saving {x} for future reference
      @nextHash += 1                        # for future hash allocation
      return object
    else                                    # singleton {x} is known
      return @objectMap[mappedHash]         # retrieving object from hash 
    end
  end

  def union(x,y)
    hx = x.hash
    hy = y.hash
    hash = SetManager.pairingCantor(hx,hy)
    mappedHash = @unionMap[hash]            # does xUy exist?
    if mappedHash == nil then               # union xUy is unknown
      @unionMap[hash] = @nextHash           # nextHash allocated to xUy
      object = Union.new(x, y, @nextHash)   # creating xUy
      @objectMap[@nextHash] = object        # saving xUy for future reference
      @nextHash += 1                        # for future hash allocation
      return object
    else                                    # union xUy is known
      return @objectMap[mappedHash]         # retrieving from hash
    end
  end

  def debug()
    (0..@nextHash-1).each{|i| puts "hash = #{i}: #{@objectMap[i]}"} 
  end
end

Set.setupManager

zero  = Set.zero
one   = Set.successor(zero)
two   = Set.successor(one)
three = Set.successor(two)
four  = Set.successor(three)
five  = Set.successor(four)

Set.debug

