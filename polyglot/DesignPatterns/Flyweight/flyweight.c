// Flyweight Design Pattern 
#include "dict.h" // Dictionary
#include <malloc.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#define FLYWEIGHT_C_MAX_BUFFER_SIZE 2048

// The main idea of the flyweight design pattern is to store objects
// in a dictionary so they can be reused, rather than new objects be
// created. This pattern is particularly well suited to classes of 
// immutable objects which is the case we shall consider here. Because
// dictionaries cannot exist without keys, the flyweight design pattern
// is closely related to the question of hashing.
//
// We shall consider the example of an inductive type Set with the three
// constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
// Union : Set -> Set -> Set. The type Set therefore corresponds to 
// the free algebra generated by a single element 0 (the empty set) and
// the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
// (inclusion) and equivalence between sets are very important, we shall 
// not consider it here and simply look at elements of type Set as syntactic
// objects. A typical OOP implementation is based on the composite  design 
// pattern which we shall adopt in this example.
//
// Objects (which are immutable) are supposed to be reused, not created.
// So the constructors of the class Set (and its subclasses) should not
// be used directly. Instead, the class should provide static factory 
// functions for 0, {x} and xUy. However, these factory functions should 
// not be simple wrappers around class constructors and should instead 
// check whether an object has previously been created.
//
// Fundamentally, we need to maintain a dictionary of created objects and
// we shall design a separate class SetManager to handle this dictionary.
// In fact the factory functions 0, {x}, xUy will be delegated to the class
// SetManager and Set will simply pass on the client's requests for object
// retrieval (or construction) to SetManager via a static member embedded
// in the class Set. As objects are being created and stored into the 
// manager's dictionary, dynamic hash values will be generated and assigned 
// to objects. The handling of hash values will also be performed by SetManager.
//
// It is possible to consider static algorithms for hash values. However, 
// these often do not guarantee that two objects with equal hash are equal. 
// It is nice to know that a static hash function is a (mathematically) 
// injective mapping. In the case at hand, such function exist but are 
// computationally unusable due to their rapid growth. Using dynamic 
// hashing, although not specifically called for by the flyweight design 
// pattern, provides the convenience of producing truly unique hashes, which 
// grow very slowly (a hash counter is incremented at each object creation). 
//
// So this example illustrate a case of flyweight design pattern, as well
// as proposing a scheme for the generation of dynamic hash values. 

typedef struct SetvTable_   SetvTable;
typedef struct Set_         Set;
typedef struct Zero_        Zero;
typedef struct Singleton_   Singleton;
typedef struct Union_       Union;
typedef struct SetManager_  SetManager;

/******************************************************************************/
/*                              Memory log                                    */
/******************************************************************************/

// basic safety scheme against memory leaks
long Set_log(const char* message, const void* address){
  static long memory_check = 0L;
  // Set_log(NULL,NULL) returns current memory_check
  if((message == NULL) && (address == NULL)) return memory_check;
  assert(message != NULL);
  assert(address != NULL);
  // message should contain %lx so fprintf expects third 'address' argument
  //fprintf(stderr, message, address);  // uncomment this line when needed
  memory_check ^= (long) address;     // xor-ing address as sanity check
//  fprintf(stderr, "checksum = %ld\n", memory_check);
  return 0L;
}

int Set_hasMemoryLeak(){
  return Set_log(NULL, NULL) != 0L || Dictionary_hasMemoryLeak();
}

/******************************************************************************/
/*                           SetvTable class                                  */
/******************************************************************************/

struct SetvTable_ {
  int   refcount;
  void  (*delete)       (Set* self); // virtual destructor
  void  (*toString)     (Set* self, char* bufffer, size_t size);
  int   (*isZero)       (Set* self);
  int   (*isSingleton)  (Set* self);
  int   (*isUnion)      (Set* self);
  Set*  (*element)      (Set* self);
  Set*  (*left)         (Set* self);
  Set*  (*right)        (Set* self);
};

SetvTable* SetvTable_new(){
  SetvTable* ptr = (SetvTable*) malloc(sizeof(SetvTable));
  assert(ptr != NULL);
  Set_log("Allocating vTable %lx\n", ptr);
  ptr->refcount     = 1;
  ptr->delete       = NULL;
  ptr->toString     = NULL;
  ptr->isZero       = NULL;
  ptr->isSingleton  = NULL;
  ptr->isUnion      = NULL;
  ptr->element      = NULL;
  ptr->left         = NULL;
  ptr->right        = NULL;
  return ptr;
}
   
SetvTable* SetvTable_copy(SetvTable* self){
  assert(self != NULL);
  self->refcount++;
  Set_log("Making copy of vTable %lx\n", self);
  return self;
}

void SetvTable_delete(SetvTable* self){
  assert(self != NULL);
  assert(self->refcount > 0);
  self->refcount--;
  if(self->refcount == 0){  // dealloc
    self->delete       = NULL;
    self->toString     = NULL;
    self->isZero       = NULL;
    self->isSingleton  = NULL;
    self->isUnion      = NULL;
    self->element      = NULL;
    self->left         = NULL;
    self->right        = NULL;
    Set_log("Deallocating vTable %lx\n", self);
    free(self);
  } else {
    Set_log("Deleting copy of vTable %lx\n", self);
  }
}

void _Zero_vTable_initialize(SetvTable*);       // forward
//
SetvTable* SetvTable_Zero_new(){
  SetvTable* ptr = SetvTable_new();
  assert(ptr != NULL);
  _Zero_vTable_initialize(ptr);
  return ptr;
}

void _Singleton_vTable_initialize(SetvTable*);  // forward
//
SetvTable* SetvTable_Singleton_new(){
  SetvTable* ptr = SetvTable_new();
  assert(ptr != NULL);
  _Singleton_vTable_initialize(ptr);
  return ptr;
}

void _Union_vTable_initialize(SetvTable*);      // forward
//
SetvTable* SetvTable_Union_new(){
  SetvTable* ptr = SetvTable_new();
  assert(ptr != NULL);
  _Union_vTable_initialize(ptr);
  return ptr;
}


// singleton design pattern. Returns instance, unless 
// required to reset instance, in which case returns NULL.
SetvTable* SetvTable_Zero_instance(int resetInstance){
  static SetvTable* instance = NULL;
  // required to reset instance
  if(resetInstance){
    if(instance != NULL) SetvTable_delete(instance);
    instance = NULL;
    return NULL;
  }
  // required to provide handle to instance
  if(instance == NULL) instance = SetvTable_Zero_new();
  return instance;
}

// singleton design pattern. Returns instance, unless 
// required to reset instance, in which case returns NULL.
SetvTable* SetvTable_Singleton_instance(int resetInstance){
  static SetvTable* instance = NULL;
  // required to reset instance
  if(resetInstance){
    if(instance != NULL) SetvTable_delete(instance);
    instance = NULL;
    return NULL;
  }
  // required to provide handle to instance
  if(instance == NULL) instance = SetvTable_Singleton_new();
  return instance;
}

// singleton design pattern. Returns instance, unless 
// required to reset instance, in which case returns NULL.
SetvTable* SetvTable_Union_instance(int resetInstance){
  static SetvTable* instance = NULL;
  // required to reset instance
  if(resetInstance){
    if(instance != NULL) SetvTable_delete(instance);
    instance = NULL;
    return NULL;
  }
  // required to provide handle to instance
  if(instance == NULL) instance = SetvTable_Union_new();
  return instance;
}

void SetvTable_test(){
  SetvTable *t = SetvTable_new();
  SetvTable *s = SetvTable_copy(t);
  SetvTable_delete(s);
  SetvTable_delete(t);

  SetvTable *zero1 = SetvTable_Zero_instance(0);
  SetvTable *zero2= SetvTable_Zero_instance(0);
  SetvTable *zero3 = SetvTable_Zero_instance(0);
  SetvTable_Zero_instance(1); // reset

  SetvTable *single1 = SetvTable_Singleton_instance(0);
  SetvTable *single2= SetvTable_Singleton_instance(0);
  SetvTable *single3 = SetvTable_Singleton_instance(0);
  SetvTable_Singleton_instance(1); // reset

  SetvTable *union1 = SetvTable_Union_instance(0);
  SetvTable *union2= SetvTable_Union_instance(0);
  SetvTable *union3 = SetvTable_Union_instance(0);
  SetvTable_Union_instance(1); // reset

  assert(!Set_hasMemoryLeak());
}

/******************************************************************************/
/*                                  Set class                                 */
/******************************************************************************/
struct Set_ {
  int         refcount;
  int         hash;
  SetvTable*  vTable;
};

// should not be called by client code
Set* Set_new(int hash){
  Set* ptr = (Set*) malloc(sizeof(Set));
  assert(ptr != NULL);
  Set_log("Allocating new base Set object %lx\n", ptr);
  ptr->refcount = 1;
  ptr->hash     = hash;
  ptr->vTable   = NULL; // to be initialized by derived class
}


Set* Set_copy(Set* self){
  assert(self != NULL);
  Set_log("Making copy of base set object %lx\n", self);
  self->refcount++;
  return self;
}

// virtual destructor
void Set_delete(Set* self){
  assert(self != NULL);
  assert(self->refcount > 0);
  assert(self->vTable != NULL);
  void (*delete)(Set*);
  delete = self->vTable->delete;
  assert(delete != NULL);
  delete(self);
}

// virtual
void Set_toString(Set* self, char* buffer, size_t size){
  assert(self != NULL);
  assert(self->vTable != NULL);
  void (*toString)(Set*, char*, size_t);
  toString = self->vTable->toString;
  assert(toString != NULL);
  toString(self, buffer, size);
}

// virtual
int Set_isZero(Set* self){
  assert(self != NULL);
  assert(self->vTable != NULL);
  int (*isZero)(Set*);
  isZero = self->vTable->isZero;
  assert(isZero != NULL);
  return isZero(self);
}

// virtual
int Set_isSingleton(Set* self){
  assert(self != NULL);
  assert(self->vTable != NULL);
  int (*isSingleton)(Set*);
  isSingleton = self->vTable->isSingleton;
  assert(isSingleton != NULL);
  return isSingleton(self);
}

// virtual
int Set_isUnion(Set* self){
  assert(self != NULL);
  assert(self->vTable != NULL);
  int (*isUnion)(Set*);
  isUnion = self->vTable->isUnion;
  assert(isUnion != NULL);
  return isUnion(self);
}

// virtual
Set* Set_element(Set* self){
  assert(self != NULL);
  assert(self->vTable != NULL);
  Set* (*element)(Set*);
  element = self->vTable->element;
  assert(element != NULL);
  return element(self);
}

// virtual
Set* Set_left(Set* self){
  assert(self != NULL);
  assert(self->vTable != NULL);
  Set* (*left)(Set*);
  left = self->vTable->left;
  assert(left != NULL);
  return left(self);
}

// virtual
Set* Set_right(Set* self){
  assert(self != NULL);
  assert(self->vTable != NULL);
  Set* (*right)(Set*);
  right = self->vTable->right;
  assert(right != NULL);
  return right(self);
}

// not a virtual method
int Set_hashCode(Set* self){
  assert(self != NULL);
  return self->hash;
}


Set* SetManager_zero();
// static method
Set* Set_zero(){
  return SetManager_zero();
}

Set* SetManager_singleton(Set*);
// static method
Set* Set_singleton(Set* x){
  assert(x != NULL);
  return SetManager_singleton(x);
}

Set* SetManager_union(Set*, Set*);
// static method
Set* Set_union(Set* x, Set* y){
  assert(x != NULL);
  assert(y != NULL);
  return SetManager_union(x,y);
}

// static method
Set* Set_successor(Set* x){
  assert(x != NULL);
  return Set_union(x, Set_singleton(x));
}

void SetManager_debug();    // forward
// static method
void Set_debug(){
  SetManager_debug();
}

void Set_test(){
  // basic
  Set* s = Set_new(123);
  assert(Set_hashCode(s) == 123);
  Set* t = Set_copy(s);
  assert(Set_hashCode(t) == 123);
  
  // virtual table is NULL, cannot delete in standard way
  Set_log("Manually deleting Set %lx\n", s); // logging required to pass leak test
  Set_log("Manually deleting Set %lx\n", t); // logging required to pass leak test
  free(t); // only once, s and t point to same memory 
  assert(!Set_hasMemoryLeak());
}

/******************************************************************************/
/*                                 Zero class                                 */
/******************************************************************************/

struct Zero_ {
  Set   base;
};


// should not be called by client code
Zero* Zero_new(int hash){
  Zero* ptr = (Zero*) malloc(sizeof(Zero));
  assert(ptr != NULL);
  Set_log("Allocating new Zero %lx\n", ptr);
  Set* base = (Set*) ptr;
  base->refcount = 1;
  base->hash = hash;
  base->vTable = SetvTable_Zero_instance(0);
  return ptr;
}

Zero* Zero_copy(Zero* self){
  assert(self != NULL);
  Set *ptr = (Set*) self;   // upcast
  ptr->refcount++;
  Set_log("Making copy of Zero %lx\n", self);
  return self;
}

// override

void SetManager_deallocate_zero(Zero*); // forward

void Zero_delete(Zero* self){
  assert(self != NULL);
  Set* base = (Set*) self;
  assert(base->refcount > 0);
  base->refcount--;
  if(base->refcount == 0){
    SetManager_deallocate_zero(self);
  } else {
    Set_log("Deleting copy of Zero %lx\n", self);
  }
}

// override
void Zero_toString(Zero* self, char* buffer, size_t size){
  assert(self != NULL);
  assert(size >= 2);
  strcpy(buffer, "0");
}

// override
int Zero_isZero(Zero* self){
  assert(self != NULL);
  return 1;   // true
}

// override
int Zero_isSingleton(Zero* self){
  assert(self != NULL);
  return 0;   // false
}

// override
int Zero_isUnion(Zero* self){
  assert(self != NULL);
  return 0;   // false
}


// override
Set* Zero_element(Zero* self){
  assert(self != NULL);
  fprintf(stderr, "Zero: illegal call to element method\n");
  assert(NULL);
  return NULL;
} 

// override
Set* Zero_left(Zero* self){
  assert(self != NULL);
  fprintf(stderr, "Zero: illegal call to left method\n");
  assert(NULL);
  return NULL;
}

// override
Set* Zero_right(Zero* self){
  assert(self != NULL);
  fprintf(stderr, "Zero: illegal call to right method\n");
  assert(NULL);
  return NULL;
}

void SetManager_deallocate(void); // forward

void Zero_test(){
  char buffer[8];
  // basic new/copy/delete test
  Zero* zero = Zero_new(0);
  Zero* copy = Zero_copy(zero);
  Zero_delete(copy);
  Zero_delete(zero);
  SetManager_deallocate();
  assert(!Set_hasMemoryLeak());
  // using real interface
  Set* set = Set_zero();          // static factory method
  assert(Set_isZero(set));
  assert(!Set_isSingleton(set));
  assert(!Set_isUnion(set));
  Set_toString(set,buffer,8);
  assert(strcmp(buffer,"0") == 0);

  SetManager_deallocate();        // overall cleanup
  assert(!Set_hasMemoryLeak());
}

/******************************************************************************/
/*                              Singleton class                               */
/******************************************************************************/

struct Singleton_ {
  Set   base;
  Set*  element;
};


// should not be called by client code
Singleton* Singleton_new(Set* element, int hash){
  assert(element != NULL);
  Singleton* ptr = (Singleton*) malloc(sizeof(Singleton));
  assert(ptr != NULL);
  Set_log("Allocating new Singleton %lx\n", ptr);
  ptr->element = element;
  Set* base = (Set*) ptr;
  base->refcount = 1;
  base->hash = hash;
  base->vTable = SetvTable_Singleton_instance(0);
  return ptr;
}

Singleton* Singleton_copy(Singleton* self){
  assert(self != NULL);
  Set *ptr = (Set*) self;   // upcast
  ptr->refcount++;
  Set_log("Making copy of Singleton %lx\n", self);
  return self;
}

void SetManager_deallocate_singleton(Singleton*); // forward
// override
void Singleton_delete(Singleton* self){
  assert(self != NULL);
  Set* base = (Set*) self;
  assert(base->refcount > 0);
  base->refcount--;
  if(base->refcount == 0){
    SetManager_deallocate_singleton(self);
  } else {
    Set_log("Deleting copy of Singleton %lx\n", self);
  }
}


// override
void Singleton_toString(Singleton* self, char* buffer, size_t size){
  char temp[FLYWEIGHT_C_MAX_BUFFER_SIZE];
  assert(self != NULL);
  assert(self->element != NULL);
  assert(size <= FLYWEIGHT_C_MAX_BUFFER_SIZE);
  assert(size >= 4); // "{0}" requires at least 4 bytes 
  Set_toString(self->element, temp, size - 2); // need to keep 2 bytes for {}
  int length = strlen(temp);
  assert(length <= size - 3); // enough space for { } and \0
  strcpy(buffer,"{"); buffer++;
  strcpy(buffer,temp); buffer += length;
  strcpy(buffer,"}");
}

// override
int Singleton_isZero(Singleton* self){
  assert(self != NULL);
  return 0;   // false
}

// override
int Singleton_isSingleton(Singleton* self){
  assert(self != NULL);
  return 1;   // true
}

// override
int Singleton_isUnion(Singleton* self){
  assert(self != NULL);
  return 0;   // false
}


// override
Set* Singleton_element(Singleton* self){
  assert(self != NULL);
  assert(self->element != NULL);
  return self->element;
} 

// override
Set* Singleton_left(Singleton* self){
  assert(self != NULL);
  fprintf(stderr, "Singleton: illegal call to left method\n");
  assert(NULL);
  return NULL;
}

// override
Set* Singleton_right(Singleton* self){
  assert(self != NULL);
  fprintf(stderr, "Singleton: illegal call to right method\n");
  assert(NULL);
  return NULL;
}


void Singleton_test(){
  char buffer[8];
  // basic new/copy/delete test
  Set* zero = (Set*) Zero_new(0);
  Singleton* single = Singleton_new(zero, 1); // does not take ownership of zero
  Singleton* copy = Singleton_copy(single);
  Singleton_delete(copy);
  Singleton_delete(single);
  Set_delete(zero);
  SetManager_deallocate();
  assert(!Set_hasMemoryLeak());
  // using higher interface
  zero = Set_zero();
  Set* one  = Set_singleton(zero);
  Set* one2 = Set_singleton(zero);
  Set* one3 = Set_singleton(zero);
  assert(!Set_isZero(one));
  assert(Set_isSingleton(one));
  assert(!Set_isUnion(one));
  assert(Set_element(one) == zero);
  assert(Set_hashCode(zero) == 0);
  assert(Set_hashCode(one) == 1);
  assert(one2 == one);
  assert(one3 == one3);
  Set_toString(one,buffer,8);
  assert(strcmp(buffer,"{0}") == 0);
  SetManager_deallocate();
  assert(!Set_hasMemoryLeak());
}



/******************************************************************************/
/*                                 Union class                                */
/******************************************************************************/

struct Union_ {
  Set   base;
  Set*  left;
  Set* right;
};


// should not be called by client code
Union* Union_new(Set* left, Set* right, int hash){
  assert(left != NULL);
  assert(right != NULL);
  Union* ptr = (Union*) malloc(sizeof(Union));
  assert(ptr != NULL);
  Set_log("Allocating new Union %lx\n", ptr);
  ptr->left = left;
  ptr->right = right;
  Set* base = (Set*) ptr;
  base->refcount = 1;
  base->hash = hash;
  base->vTable = SetvTable_Union_instance(0);
  return ptr;
}

Union* Union_copy(Union* self){
  assert(self != NULL);
  Set *ptr = (Set*) self;   // upcast
  ptr->refcount++;
  Set_log("Making copy of Union %lx\n", self);
  return self;
}

void SetManager_deallocate_union(Union*); // forward

// override
void Union_delete(Union* self){
  assert(self != NULL);
  Set* base = (Set*) self;
  assert(base->refcount > 0);
  base->refcount--;
  if(base->refcount == 0){
    SetManager_deallocate_union(self);
  } else {
    Set_log("Deleting copy of Union %lx\n", self);
  }
}


// override
void Union_toString(Union* self, char* buffer, size_t size){
  char temp[FLYWEIGHT_C_MAX_BUFFER_SIZE];
  assert(self != NULL);
  assert(self->left != NULL);
  assert(self->right != NULL);
  assert(size <= FLYWEIGHT_C_MAX_BUFFER_SIZE);
  assert(size >= 4);  // "0U0" requires size bytes 
  Set_toString(self->left, temp, size - 2); // need to keep 4 bytes for U0
  int length = strlen(temp);
  assert(length < size - 2); // enough space for  U 0  and \0
  strcpy(buffer, temp); buffer += length;
  strcpy(buffer, "U");  buffer++;
  Set_toString(self->right, temp, size - length - 2); //  U  and \0
  length = strlen(temp);
  assert(length <= size - length -2);
  strcpy(buffer, temp); buffer +=length;
}

// override
int Union_isZero(Union* self){
  assert(self != NULL);
  return 0;   // false
}

// override
int Union_isSingleton(Union* self){
  assert(self != NULL);
  return 0;   // true
}

// override
int Union_isUnion(Union* self){
  assert(self != NULL);
  return 1;   // false
}


// override
Set* Union_element(Union* self){
  assert(self != NULL);
  fprintf(stderr, "Union: illegal call to element method\n");
  assert(NULL);
  return NULL;
} 

// override
Set* Union_left(Union* self){
  assert(self != NULL);
  assert(self->left != NULL);
  return self->left;
}

// override
Set* Union_right(Union* self){
  assert(self != NULL);
  assert(self->right != NULL);
  return self->right;
}


void Union_test(){
  char buffer[32];
  // basic new/copy/delete test
  Zero* zero = Zero_new(0);
  // Singleton_new does not take ownership of zero: need to deallocate
  Singleton* single = Singleton_new((Set*)zero, 1);
  // Union_new does not take ownership of arguments: need to deallocate
  Union* union_ = Union_new((Set*) zero, (Set*) single, 2);
  Union* copy = Union_copy(union_);
  // SetManager_deallocate would normally deallocate SetManager and consequently
  // all set objects stored within it. However, no set manager has been created
  // thus far, and set objects have been created directly with 'new' (which client
  // should not do). So we need to deallocate set objects ourself to avoid leaks.
  // A call to SetManager_deallocate is still required to clean up virtual tables.
  Union_delete(copy);
  Union_delete(union_);
  Singleton_delete(single);
  Zero_delete(zero);
  SetManager_deallocate();      // virtual tables
  assert(!Set_hasMemoryLeak());
  // Testing static interface
  Set* empty  = Set_zero();
  Set* one    = Set_singleton(empty);
  Set* two    = Set_union(one, Set_singleton(one));
  Set* s_one  = Set_singleton(one);
  Set* two_   = Set_union(one, s_one);
  Set* empty_ = Set_zero();
  Set* one_   = Set_singleton(empty_);
  // objects were not replicated, but instead re-used
  assert(empty == empty_);
  assert(one   == one_);
  assert(two   == two_);
  // checking hash values
  assert(Set_hashCode(empty)  == 0);
  assert(Set_hashCode(one)    == 1);
  assert(Set_hashCode(s_one)  == 2);
  assert(Set_hashCode(two)    == 3);
  // checking union properties
  assert(!Set_isZero(two));
  assert(!Set_isSingleton(two));
  assert(Set_isUnion(two));
  assert(Set_left(two) == one);
  assert(Set_right(two) == s_one);
  // checking Singleton properties
  assert(!Set_isZero(one));
  assert(Set_isSingleton(one));
  assert(!Set_isUnion(one));
  assert(Set_element(one) == empty);
  // toString
  Set_toString(empty,buffer,32);
  assert(strcmp(buffer, "0") == 0);
  Set_toString(one,buffer,32);
  assert(strcmp(buffer, "{0}") == 0);
  Set_toString(s_one,buffer,32);
  assert(strcmp(buffer, "{{0}}") == 0);
  Set_toString(two,buffer,32);
  assert(strcmp(buffer, "({0}U{{0}})") == 0);
  // deallocating set manager, all sets and virtual tables
  SetManager_deallocate(); 
  assert(!Set_hasMemoryLeak());
}

/******************************************************************************/
/*                             SetManager class                               */
/******************************************************************************/

struct SetManager_ {
  int   refcount;
  int   nextHash;
  Dictionary* singletonMap;
  Dictionary* unionMap;
  Dictionary* objectMap;
};


SetManager* SetManager_new(){
  SetManager* ptr = (SetManager*) malloc(sizeof(SetManager));
  assert(ptr != NULL);
  Set_log("Allocating new SetManager %lx\n", ptr);
  ptr->refcount = 1;
  ptr->nextHash = 1;
  ptr->singletonMap = Dictionary_new();
  ptr->unionMap     = Dictionary_new();
  ptr->objectMap    = Dictionary_new();
  assert(ptr->singletonMap  != NULL);
  assert(ptr->unionMap      != NULL);
  assert(ptr->objectMap     != NULL);
  Set* zero = (Set*) Zero_new(0);
  Dictionary_insert(ptr->objectMap, 0, zero); 
  return ptr;
}

SetManager* SetManager_copy(SetManager* self){
  assert(self != NULL);
  self->refcount++;
  Set_log("Making copy of setManager %lx\n", self);
  return self;
}


void SetManager_delete(SetManager* self){
  assert(self != NULL);
  assert(self->refcount > 0);
  self->refcount--;
  if(self->refcount == 0){
    assert(self->singletonMap  != NULL);
    assert(self->unionMap      != NULL);
    assert(self->objectMap     != NULL);
    // deallocation of sets
    int i;
    for(i = 0; i < self->nextHash; ++i){ // looping through all allocated hash
      const void* result;
      int found = Dictionary_find(self->objectMap, i, &result);
      assert(found);
      assert(result != NULL);
      Set_delete((Set*) result);         // deleting corresponding Set object.
    }
    Dictionary_delete(self->singletonMap);
    Dictionary_delete(self->unionMap);
    Dictionary_delete(self->objectMap);
    self->nextHash      = 0;
    self->singletonMap  = NULL;
    self->unionMap      = NULL;
    self->objectMap     = NULL;
    Set_log("Deallocating SetManager %lx\n", self);
    free(self);
  } else {
    Set_log("Deleting copy of SetManager %lx\n", self);
  }
}


SetManager* SetManager_instance(int);
//
void SetManager_deallocate(){            // final clean up
  SetManager_instance(1);           // deallocating set manager
  SetvTable_Zero_instance(1);       // deallocating vTable
  SetvTable_Singleton_instance(1);  // deallocating vTable
  SetvTable_Union_instance(1);      // deallocating vTable
}

void SetManager_deallocate_zero(Zero* obj){
  // temporary
  assert(obj != NULL);
  Set* ptr = (Set*) obj; 
  assert(ptr->refcount == 0);
  assert(ptr->vTable != NULL);
  assert(ptr->vTable == SetvTable_Zero_instance(0));
  Set_log("Deallocating Zero %lx\n", obj);
  free(obj);
}

void SetManager_deallocate_singleton(Singleton* obj){
  // temporary
  assert(obj != NULL);
  Set* ptr = (Set*) obj; 
  assert(ptr->refcount == 0);
  assert(ptr->vTable != NULL);
  assert(ptr->vTable == SetvTable_Singleton_instance(0));
  // singleton object does not have ownership of its element
  // hence this code should not attempt to delete it. 
  Set_log("Deallocating Singleton %lx\n", obj);
  free(obj);
}

void SetManager_deallocate_union(Union* obj){
  // temporary
  assert(obj != NULL);
  Set* ptr = (Set*) obj; 
  assert(ptr->refcount == 0);
  assert(ptr->vTable != NULL);
  assert(ptr->vTable == SetvTable_Union_instance(0));
  // union object does not have ownership of its left and right components
  // hence this code should not attempt to delete left or right.
  Set_log("Deallocating Union %lx\n", obj);
  free(obj);
}

// singleton design pattern for SetManager
// returns unique instance of SetManager if resetInstance = 0
// returns NULL and reset instance if resetIntance = 1
SetManager* SetManager_instance(int resetInstance){
  static SetManager* instance = NULL;
  if(resetInstance){
    if(instance != NULL) SetManager_delete(instance);
    instance = NULL;
    return NULL;
  }
  if(instance == NULL) instance = SetManager_new();
  return instance;
}

Set* SetManager_zero(){
  // be careful if you are trying to design a memoized version of this
  // SetManager_instance(1) can deallocate current SetManager
  // so live SetManager instance may change.
  const void* result;
  SetManager* manager = SetManager_instance(0);
  assert(manager != NULL);
  assert(manager->objectMap != NULL);
  int found = Dictionary_find(manager->objectMap, 0, &result); // set with hash 0
  assert(found);
  assert(result != NULL);
  return (Set*) result;
}

Set* SetManager_singleton(Set* x){
  assert(x != NULL);
  SetManager* manager = SetManager_instance(0);
  assert(manager != NULL);
  assert(manager->singletonMap != NULL);
  assert(manager->objectMap    != NULL);
  int hash = Set_hashCode(x);
  const void* result; // needed for dictionary search
  int found = Dictionary_find(manager->singletonMap, hash, &result);// {x} exists?
  if(!found){ // singleton {x} is unknown
    // rather than boxing hash values, we convert them to (void*) pointers
    const void* newHashAsPointer = (void*) ((long) manager->nextHash);
    // allocating nextHash to {x}
    Dictionary_insert(manager->singletonMap, hash, newHashAsPointer);
    // creating object {x} with new hash
    Set* object = (Set*) Singleton_new(x, manager->nextHash);
    // saving {x} for future reference
    Dictionary_insert(manager->objectMap, manager->nextHash, object);
    // required for future hash allocation
    manager->nextHash++;
    return object;
  } else { // singleton {x} is known, its hash value in 'result' (as a void*)
    long key = (long) result; // conversion to long to avoid compiler warning
    found = Dictionary_find(manager->objectMap, (int) key, &result);
    assert(found);
    assert(result != NULL);
    return (Set*) result;
  }
}
int SetManager_pairingCantor(int x, int y){
  return (x + y + 1)*(x + y)/2 + y; // '/' is integer division
}
Set* SetManager_union(Set* x, Set* y){
  assert(x != NULL);
  assert(y != NULL);
  SetManager* manager = SetManager_instance(0);
  assert(manager != NULL);
  assert(manager->unionMap != NULL);
  assert(manager->objectMap != NULL);
  int hx = Set_hashCode(x);
  int hy = Set_hashCode(y);
  int hash = SetManager_pairingCantor(hx,hy);
  const void* result; // needed for dictionary search
  int found = Dictionary_find(manager->unionMap, hash, &result); // xUy exists?
  if(!found){ // union xUy is unknown
    // rather than boxing hash values, we convert them to (void*) pointers
    const void* newHashAsPointer = (void*) ((long) manager->nextHash);
    // allocating new hash to xUy
    Dictionary_insert(manager->unionMap, hash, newHashAsPointer);
    // creating object xUy with new hash
    Set* object = (Set*) Union_new(x, y, manager->nextHash);
    // saving xUy for future reference
    Dictionary_insert(manager->objectMap, manager->nextHash, object);
    // required for future hash allocation
    manager->nextHash++;
    return object;
  } else {  // union xUy is known, its hash value in 'result' (as void*)
    long key = (long) result; // conversion to long to avoid compiler warning
    found = Dictionary_find(manager->objectMap, (int) key, &result);
    assert(found);
    assert(result != NULL);
    return (Set*) result;
  }
}

void SetManager_debug(){
  char buffer[FLYWEIGHT_C_MAX_BUFFER_SIZE];
  int i;
  const void* result;
  int found;

  SetManager* manager = SetManager_instance(0);
  assert(manager != NULL);
  for(i = 0; i < manager->nextHash; ++i){  
    found = Dictionary_find(manager->objectMap, i, &result);
    assert(found);
    assert(result != NULL);
    Set_toString((Set*) result, buffer, FLYWEIGHT_C_MAX_BUFFER_SIZE);
    printf("hash = %d: %s\n", i, buffer);
  }
}

void SetManager_test(){

  // basic new/copy/delete test
  SetManager* manager = SetManager_new();
  SetManager* copy = SetManager_copy(manager);
  SetManager_delete(copy);
  SetManager_delete(manager);
  SetManager_deallocate();

  assert(!Set_hasMemoryLeak());

  SetManager* manager1 = SetManager_instance(0); 
  SetManager* manager2 = SetManager_instance(0); 
  SetManager* manager3 = SetManager_instance(0); 
  assert(manager1 != NULL);
  assert(manager1 == manager2);
  assert(manager1 == manager3);
  SetManager_instance(1); // deallocating instance
  
  // final clean up such as virtual tables
  SetManager_deallocate();
  assert(!Set_hasMemoryLeak());
}

/******************************************************************************/
/*                         vTable initializers  (Zero)                        */
/******************************************************************************/

void _Zero_toString(Set* self, char* buffer, size_t size){
  assert(self != NULL);
  Zero_toString((Zero*) self, buffer, size); // downcast
}

int _Zero_isZero(Set* self){
  assert(self != NULL);
  return Zero_isZero((Zero*) self);          // downcast
}

int _Zero_isSingleton(Set* self){
  assert(self != NULL);
  return Zero_isSingleton((Zero*) self);     // downcast
}

int _Zero_isUnion(Set* self){
  assert(self != NULL);
  return Zero_isUnion((Zero*) self);         // downcast
}


Set* _Zero_element(Set* self){
  assert(self != NULL);
  return Zero_element((Zero*) self);         // downcast
} 

Set* _Zero_left(Set* self){
  assert(self != NULL);
  return Zero_left((Zero*) self);            // downcast
}

Set* _Zero_right(Set* self){
  assert(self != NULL);
  return Zero_right((Zero*) self);           // downcast
}

void _Zero_delete(Set* self){
  assert(self != NULL);
  Zero_delete((Zero*) self);                 // downcast
}

void _Zero_vTable_initialize(SetvTable* vTable){
  assert(vTable != NULL);
  vTable->delete      = _Zero_delete; 
  vTable->toString    = _Zero_toString;
  vTable->isZero      = _Zero_isZero;
  vTable->isSingleton = _Zero_isSingleton;
  vTable->isUnion     = _Zero_isUnion;
  vTable->element     = _Zero_element;
  vTable->left        = _Zero_left;
  vTable->right       = _Zero_right;
}

/******************************************************************************/
/*                      vTable initializers  (Singleton)                      */
/******************************************************************************/

void _Singleton_toString(Set* self, char* buffer, size_t size){
  assert(self != NULL);
  Singleton_toString((Singleton*) self, buffer, size); // downcast
}

int _Singleton_isZero(Set* self){
  assert(self != NULL);
  return Singleton_isZero((Singleton*) self);     // downcast
}

int _Singleton_isSingleton(Set* self){
  assert(self != NULL);
  return Singleton_isSingleton((Singleton*) self);     // downcast
}

int _Singleton_isUnion(Set* self){
  assert(self != NULL);
  return Singleton_isUnion((Singleton*) self);         // downcast
}


Set* _Singleton_element(Set* self){
  assert(self != NULL);
  return Singleton_element((Singleton*) self);         // downcast
} 

Set* _Singleton_left(Set* self){
  assert(self != NULL);
  return Singleton_left((Singleton*) self);            // downcast
}

Set* _Singleton_right(Set* self){
  assert(self != NULL);
  return Singleton_right((Singleton*) self);           // downcast
}

void _Singleton_delete(Set* self){
  assert(self != NULL);
  Singleton_delete((Singleton*) self);                 // downcast
}

void _Singleton_vTable_initialize(SetvTable* vTable){
  assert(vTable != NULL);
  vTable->delete      = _Singleton_delete; 
  vTable->toString    = _Singleton_toString;
  vTable->isZero      = _Singleton_isZero;
  vTable->isSingleton = _Singleton_isSingleton;
  vTable->isUnion     = _Singleton_isUnion;
  vTable->element     = _Singleton_element;
  vTable->left        = _Singleton_left;
  vTable->right       = _Singleton_right;
}


/******************************************************************************/
/*                      vTable initializers  (Union)                          */
/******************************************************************************/

void _Union_toString(Set* self, char* buffer, size_t size){
  assert(self != NULL);
  Union_toString((Union*) self, buffer, size); // downcast
}

int _Union_isZero(Set* self){
  assert(self != NULL);
  return Union_isZero((Union*) self);          // downcast
}

int _Union_isSingleton(Set* self){
  assert(self != NULL);
  return Union_isSingleton((Union*) self);     // downcast
}

int _Union_isUnion(Set* self){
  assert(self != NULL);
  return Union_isUnion((Union*) self);         // downcast
}


Set* _Union_element(Set* self){
  assert(self != NULL);
  return Union_element((Union*) self);         // downcast
} 

Set* _Union_left(Set* self){
  assert(self != NULL);
  return Union_left((Union*) self);            // downcast
}

Set* _Union_right(Set* self){
  assert(self != NULL);
  return Union_right((Union*) self);           // downcast
}

void _Union_delete(Set* self){
  assert(self != NULL);
  Union_delete((Union*) self);                 // downcast
}

void _Union_vTable_initialize(SetvTable* vTable){
  assert(vTable != NULL);
  vTable->delete      = _Union_delete; 
  vTable->toString    = _Union_toString;
  vTable->isZero      = _Union_isZero;
  vTable->isSingleton = _Union_isSingleton;
  vTable->isUnion     = _Union_isUnion;
  vTable->element     = _Union_element;
  vTable->left        = _Union_left;
  vTable->right       = _Union_right;
}

void flyweight_test(){
  Set_test();
  SetvTable_test(); 
  Zero_test();
  Singleton_test();
  Union_test();
  SetManager_test();
}

int main(){

  Set* zero   = Set_zero();
  Set* one    = Set_successor(zero);
  Set* two    = Set_successor(one);
  Set* three  = Set_successor(two);
  Set* four   = Set_successor(three);
  Set* five   = Set_successor(four);

  Set_debug();
 

  // cleaning up set manager, sets and virtual tables
  SetManager_deallocate();  
  assert(!Set_hasMemoryLeak());

  return 0;
}
