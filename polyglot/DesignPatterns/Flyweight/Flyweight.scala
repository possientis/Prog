// Flyweight Design Pattern

// The main idea of the flyweight design pattern is to store objects
// in a dictionary so they can be reused, rather than new objects be
// created. This pattern is particularly well suited to classes of 
// immutable objects which is the case we shall consider here. Because
// dictionaries cannot exist without keys, the flyweight design pattern
// is closely related to the question of hashing.
//
// We shall consider the example of an inductive type Set with the three
// constructors (i) Zero : Set,  (ii) Singleton : Set-> Set and (iii)
// Union : Set -> Set -> Set. The type Set therefore corresponds to 
// the free algebra generated by a single element 0 (the empty set) and
// the operators x -> {x} and x,y -> xUy. Although, the questions of preorder
// (inclusion) and equivalence between sets are very important, we shall 
// not consider it here and simply look at elements of type Set as syntactic
// objects. A typical OOP implementation is based on the composite  design 
// pattern which we shall adopt in this example.
//
// Objects (which are immutable) are supposed to be reused, not created.
// So the constructors of the class Set (and its subclasses) should not
// be used directly. Instead, the class should provide static factory 
// functions for 0, {x} and xUy. However, these factory functions should 
// not be simple wrappers around class constructors and should instead 
// check whether an object has previously been created.
//
// Fundamentally, we need to maintain a dictionary of created objects and
// we shall design a separate class SetManager to handle this dictionary.
// In fact the factory functions 0, {x}, xUy will be delegated to the class
// SetManager and Set will simply pass on the client's requests for object
// retrieval (or construction) to SetManager via a static member embedded
// in the class Set. As objects are being created and stored into the 
// manager's dictionary, dynamic hash values will be generated and assigned 
// to objects. The handling of hash values will also be performed by SetManager.
//
// It is possible to consider static algorithms for hash values. However, 
// these often do not guarantee that two objects with equal hash are equal. 
// It is nice to know that a static hash function is a (mathematically) 
// injective mapping. In the case at hand, such function exist but are 
// computationally unusable due to their rapid growth. Using dynamic hashing, 
// although not specifically called for by the flyweight design pattern, 
// provides the convenience of producing truly unique hashes, which grow very 
// slowly (a hash counter is incremented at each object creation). 
//
// So this example illustrate a case of flyweight design pattern, as well
// as proposing a scheme for the generation of dynamic hash values. 

abstract class Set(hash: Int){
  override  def hashCode = hash
  override  def toString    : String
            def isZero      : Boolean
            def isSingleton : Boolean
            def isUnion     : Boolean
            def element     : Set
            def left        : Set
            def right       : Set
}

case class Zero(hash: Int) extends Set(hash) {
  override def toString    = "0"
  override def isZero      = true
  override def isSingleton = false
  override def isUnion     = false
  override def element     = throw new Exception("empty set has no element") 
  override def left        = throw new Exception("empty set has no left element") 
  override def right       = throw new Exception("empty set has no right element") 
}

case class Singleton(x: Set, hash: Int)     extends Set(hash){
  override def toString    = "{" + x + "}"
  override def isZero      = false
  override def isSingleton = true
  override def isUnion     = false
  override def element     = x
  override def left        = throw new Exception("illegal operation on singleton") 
  override def right       = throw new Exception("illegal operation on singleton") 
}

case class Union(x: Set, y: Set, hash: Int) extends Set(hash){
  override def toString    = x + "U" + y
  override def isZero      = false
  override def isSingleton = false
  override def isUnion     = true
  override def element     = throw new Exception("illegal operation on union") 
  override def left        = x 
  override def right       = y 
}

object Set {
  protected val manager     = SetManager
  def zero                  = manager.zero
  def singleton(x: Set)     = manager.singleton(x)
  def union(x: Set, y:Set)  = manager.union(x, y)
  def successor(x: Set)     = union(x, singleton(x))
  def debug()               = manager.debug()
}

object SetManager {
  private var nextHash      = 1
  private var singletonMap  = Map[Int, Int]()
  private var unionMap      = Map[Int, Int]()
  private var objectMap     = Map[Int, Set](0 -> Zero(0))
  def pairingCantor(x:Int, y:Int): Int = (x + y + 1)*(x + y)/2 + y
  def zero                  = objectMap(0)
  def singleton(x: Set)     = {
    val hash = x.hashCode
    singletonMap.get(hash) match {          // finding out whether {x} exists
      case None             => {            // singleton {x} is unknown
        singletonMap += (hash -> nextHash)  // nextHash allocated to {x}
        val set = Singleton(x, nextHash)    // creating {x}
        objectMap += (nextHash -> set)      // saving {x} for future reference
        nextHash += 1                       // for future hash allocation
        set                                 // returning {x}
      }
      case Some(mappedHash) => {
        objectMap(mappedHash)               // simply returning object from hash
      }
    }
  }

  def union(x: Set, y: Set) = {
    val hx = x.hashCode
    val hy = y.hashCode
    val hash = pairingCantor(hx, hy)
    unionMap.get(hash) match {              // finding out whether xUy exists
      case None             => {            // union xUy is unknown
        unionMap += (hash -> nextHash)      // nextHash allocated to xUy
        val set = Union(x, y, nextHash)     // creating xUy
        objectMap += (nextHash -> set)      // saving xUy for future reference
        nextHash += 1                       // for future hash allocation
        set                                 // returning xUy
      }
      case Some(mappedHash) => {
        objectMap(mappedHash)               // simply returning object from hash
      }
    }
  }
  
  def debug() = {
    for(i <- 0 until nextHash){
      println("hash = " + i + ": " + objectMap(i))
    }
  } 
}

object Flyweight {
  def main(args: Array[String]){
    val zero  = Set.zero
    val one   = Set.successor(zero) 
    val two   = Set.successor(one)
    val three = Set.successor(two)
    val four  = Set.successor(three)
    val five  = Set.successor(four)
    Set.debug()
  }
}

