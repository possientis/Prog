Require Import Logic.Class.Eq.

Require Import Logic.Func.Replace.

Require Import Logic.List.In.

Require Import Logic.Rel.Include.

Require Import Logic.Fol.Free.
Require Import Logic.Fol.Syntax.
Require Import Logic.Fol.Functor.
Require Import Logic.Fol.Variable.
Require Import Logic.Fol.Congruence.

(* Generator of strong alpha-equivalence.                                       *)
Inductive StrongAlpha0 (v:Type) (e:Eq v) : P v -> P v -> Prop :=
| mkStrongAlpha0: forall (x y:v) (p1:P v), 
    x <> y        -> 
    ~ y :: var p1 ->
    StrongAlpha0 v e (All x p1) (All y (fmap (y // x) p1)) 
.

Arguments StrongAlpha0 {v} {e}.
Arguments mkStrongAlpha0 {v} {e}.

(* The strong alpha-equivalence is the congruence generated by StrongAlph0.     *)
Definition StrongAlpha (v:Type) (e:Eq v) : P v -> P v -> Prop := 
    Cong (@StrongAlpha0 v e).

Arguments StrongAlpha {v} {e}.

Notation "p ~ q" := (StrongAlpha p q)
    (at level 60, no associativity) : Fol_StrongAlpha_scope.

Open Scope Fol_StrongAlpha_scope.

(*
Lemma StrongAlpha_free : forall (v:Type) (e:Eq v) (p q:P v), 
    p ~ q -> Fr p = Fr q.
Proof.
    intros v e. apply incl_charac. apply Cong_smallest.
    - apply free_congruence.
    - apply incl_charac. intros x y H1. destruct H1 as [x y p1 H1 H2]. 
Show.
*)
