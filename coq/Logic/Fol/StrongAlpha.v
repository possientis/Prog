Require Import List.

Require Import Logic.Class.Eq.

Require Import Logic.Func.Replace.
Require Import Logic.Func.Permute.
Require Import Logic.Func.Injective.
Require Import Logic.Func.Composition.

Require Import Logic.List.In.
Require Import Logic.List.Remove.
Require Import Logic.List.Coincide.
Require Import Logic.List.Difference.

Require Import Logic.Rel.Include.

Require Import Logic.Fol.Free.
Require Import Logic.Fol.Valid.
Require Import Logic.Fol.Syntax.
Require Import Logic.Fol.Functor.
Require Import Logic.Fol.Variable.
Require Import Logic.Fol.Subformula.
Require Import Logic.Fol.Congruence.

(* Generator of strong alpha-equivalence.                                       *)
Inductive StrongAlpha0 (v:Type) (e:Eq v) : P v -> P v -> Prop :=
| mkStrongAlpha0: forall (x y:v) (p1:P v), 
    x <> y        -> 
    ~ y :: var p1 ->
    StrongAlpha0 v e (All x p1) (All y (fmap (y // x) p1)) 
.

Arguments StrongAlpha0 {v} {e}.
Arguments mkStrongAlpha0 {v} {e}.

(* The strong alpha-equivalence is the congruence generated by StrongAlph0.     *)
Definition StrongAlpha (v:Type) (e:Eq v) : P v -> P v -> Prop := 
    Cong (@StrongAlpha0 v e).

Arguments StrongAlpha {v} {e}.

Notation "p ~ q" := (StrongAlpha p q)
    (at level 60, no associativity) : Fol_StrongAlpha_scope.

Open Scope Fol_StrongAlpha_scope.

(* Not following pdf to obtain stronger result of equality as lists.            *)
Lemma StrongAlpha_free : forall (v:Type) (e:Eq v) (p q:P v), 
    p ~ q -> Fr p = Fr q.
Proof.
    intros v e. apply incl_charac, Cong_smallest.
    - apply free_congruence.
    - apply incl_charac. intros x y H1. destruct H1 as [x y p1 H1 H2]. simpl.
      assert (valid (y // x) p1) as H3. { apply valid_replace. assumption. }
      assert (Fr (fmap (y // x) p1) = map (y // x) (Fr p1)) as H4.
        { destruct (valid_free v v e e (y // x) p1) as [H5 H6].
          apply H5.
            { apply H3. } 
            { apply Sub_refl. }}
      rewrite H4. assert (y = (y // x) x) as H7.
        { rewrite replace_x. reflexivity. } 
      rewrite H7 at 1. clear H3 H4 H7. rewrite (remove_map v v e e).
        + rewrite (coincide_map v v (y //x) id).
            { symmetry. apply map_id. }
            { intros u H3. apply replace_not_x. unfold id. intros H4. 
              subst. revert H3. apply remove_x_gone. }
        + intros u H3 H4. rewrite replace_x. rewrite replace_not_x; 
          intros H5; subst.
            { apply H2. apply (free_var v e). assumption. }
            { apply H3. reflexivity. }
Qed.

Lemma StrongAlpha_injective : 
    forall (v w:Type) (e:Eq v) (e':Eq w) (f:v -> w) (p q:P v),
        injective f -> p ~ q -> fmap f p ~ fmap f q.
Proof.
    intros v w e e' f p q H1 H2. revert p q H2. 
    apply incl_charac, Cong_smallest.
    - apply fmap_congruence, Cong_congruence.
    - apply incl_charac. intros p q H2. destruct H2 as [x y p1 H2 H3]. simpl.
      apply CongBase. rewrite <- fmap_comp'. 
      assert (f ; (y // x) = (f y // f x) ; f) as H4. {
        apply replace_injective. assumption. }
      rewrite H4. rewrite fmap_comp. constructor.
        + intros H5. apply H2, H1. assumption.
        + intros H5. rewrite var_fmap in H5. apply in_map_iff in H5.
          destruct H5 as [u [H5 H6]]. apply H1 in H5. subst.
          apply H3 in H6. contradiction.
Qed.

Lemma StrongAlpha_replace : 
    forall (v:Type) (e:Eq v) (p q:P v) (x y:v),
        ~ y :: var p -> ~ y :: var q -> 
            p ~ q -> fmap (y // x) p ~ fmap (y // x) q.
Proof.
    intros v e p q x y H1 H2 H3.
    assert (fmap (y // x) p = fmap (y <:> x) p) as H4.
        { apply var_replace_permute. assumption. }
    assert (fmap (y // x) q = fmap (y <:> x) q) as H5.
        { apply var_replace_permute. assumption. }
    rewrite H4, H5. apply (StrongAlpha_injective _ _ _).
    apply permute_injective. assumption.
Qed.
