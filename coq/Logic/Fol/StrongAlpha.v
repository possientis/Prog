Require Import List.

Require Import Logic.Class.Eq.

Require Import Logic.Func.Replace.
Require Import Logic.Func.Permute.
Require Import Logic.Func.Identity.
Require Import Logic.Func.Injective.
Require Import Logic.Func.Composition.

Require Import Logic.List.In.
Require Import Logic.List.Remove.
Require Import Logic.List.Coincide.
Require Import Logic.List.Difference.

Require Import Logic.Rel.Include.

Require Import Logic.Fol.Free.
Require Import Logic.Fol.Valid.
Require Import Logic.Fol.Syntax.
Require Import Logic.Fol.Functor.
Require Import Logic.Fol.Variable.
Require Import Logic.Fol.Subformula.
Require Import Logic.Fol.Congruence.


(* Generator of strong alpha-equivalence.                                       *)
Inductive StrongAlpha0 (v:Type) (e:Eq v) : P v -> P v -> Prop :=
| mkStrongAlpha0: forall (x y:v) (p1:P v), 
    x <> y        -> 
    ~ y :: var p1 ->
    StrongAlpha0 v e (All x p1) (All y (fmap (y // x) p1)) 
.

Arguments StrongAlpha0 {v} {e}.
Arguments mkStrongAlpha0 {v} {e}.

(* The strong alpha-equivalence is the congruence generated by StrongAlph0.     *)
Definition StrongAlpha (v:Type) (e:Eq v) : P v -> P v -> Prop := 
    Cong (@StrongAlpha0 v e).

Arguments StrongAlpha {v} {e}.

Notation "p ~ q" := (StrongAlpha p q)
    (at level 60, no associativity) : Fol_StrongAlpha_scope.

Open Scope Fol_StrongAlpha_scope.

(* Not following pdf to obtain stronger result of equality as lists.            *)
Lemma StrongAlpha_free : forall (v:Type) (e:Eq v) (p q:P v), 
    p ~ q -> Fr p = Fr q.
Proof.
    intros v e. apply incl_charac, Cong_smallest.
    - apply free_congruence.
    - apply incl_charac. intros x y H1. destruct H1 as [x y p1 H1 H2]. simpl.
      assert (valid (y // x) p1) as H3. { apply valid_replace. assumption. }
      assert (Fr (fmap (y // x) p1) = map (y // x) (Fr p1)) as H4.
        { destruct (valid_free v v e e (y // x) p1) as [H5 H6].
          apply H5.
            { apply H3. } 
            { apply Sub_refl. }}
      rewrite H4. assert (y = (y // x) x) as H7.
        { rewrite replace_x. reflexivity. } 
      rewrite H7 at 1. clear H3 H4 H7. rewrite (remove_map v v e e).
        + rewrite (coincide_map v v (y //x) id).
            { symmetry. apply map_id. }
            { intros u H3. apply replace_not_x. unfold id. intros H4. 
              subst. revert H3. apply remove_x_gone. }
        + intros u H3 H4. rewrite replace_x. rewrite replace_not_x; 
          intros H5; subst.
            { apply H2. apply (free_var v e). assumption. }
            { apply H3. reflexivity. }
Qed.

(* Strong alpha-equivalence is preserved by injective maps.                     *)
Lemma StrongAlpha_injective : 
    forall (v w:Type) (e:Eq v) (e':Eq w) (f:v -> w) (p q:P v),
        injective f -> p ~ q -> fmap f p ~ fmap f q.
Proof.
    intros v w e e' f p q H1 H2. revert p q H2. 
    apply incl_charac, Cong_smallest.
    - apply fmap_congruence, Cong_congruence.
    - apply incl_charac. intros p q H2. destruct H2 as [x y p1 H2 H3]. simpl.
      apply CongBase. rewrite <- fmap_comp'. 
      assert (f ; (y // x) = (f y // f x) ; f) as H4. {
        apply replace_injective. assumption. }
      rewrite H4. rewrite fmap_comp. constructor.
        + intros H5. apply H2, H1. assumption.
        + intros H5. rewrite var_fmap in H5. apply in_map_iff in H5.
          destruct H5 as [u [H5 H6]]. apply H1 in H5. subst.
          apply H3 in H6. contradiction.
Qed.

(* Strong alpha-equivalence is preserved by var replacement with caveat.        *)
Lemma StrongAlpha_replace : 
    forall (v:Type) (e:Eq v) (p q:P v) (x y:v),
        ~ y :: var p -> ~ y :: var q -> 
            p ~ q -> fmap (y // x) p ~ fmap (y // x) q.
Proof.
    intros v e p q x y H1 H2 H3.
    assert (fmap (y // x) p = fmap (y <:> x) p) as H4.
        { apply var_replace_permute. assumption. }
    assert (fmap (y // x) q = fmap (y <:> x) q) as H5.
        { apply var_replace_permute. assumption. }
    rewrite H4, H5. apply (StrongAlpha_injective _ _ _).
    apply permute_injective. assumption.
Qed.

(* Strong alpha-equivalence class unchanged by var replacement with caveat.     *)
Lemma StrongAlpha_replace_self:
    forall (v:Type) (e:Eq v) (p:P v) (x y:v),
        ~ y :: var p -> 
        ~ x :: Fr p  ->
        fmap (y // x) p ~ p.
Proof.
    intros v e p x y. revert p. 
    induction p as [|x' y'|p1 IH1 p2 IH2|x' p1 IH1]; 
    intros H1 H2; simpl; simpl in H1; simpl in H2.
    - apply Cong_reflexive.
    - unfold replace. 
      destruct (eqDec x' x) as [H3|H3]; destruct (eqDec y' x) as [H4|H4].
        + subst. exfalso. apply H2. left. reflexivity.
        + subst. exfalso. apply H2. left. reflexivity.
        + subst. exfalso. apply H2. right. left. reflexivity.
        + apply Cong_reflexive.
    - apply CongImp.
        + apply IH1; intros H3.
            { apply H1, in_or_app. left. assumption. }
            { apply H2, in_or_app. left. assumption. }
        + apply IH2; intros H3.
            { apply H1, in_or_app. right. assumption. }
            { apply H2, in_or_app. right. assumption. }
    - unfold replace. destruct (eqDec x' x) as [H3|H3].
        + subst. destruct (eqDec x y) as [H4|H4].
            { subst. apply CongAll. fold (y // y). rewrite replace_x_x.
              rewrite fmap_id. apply Cong_reflexive. }
            { fold (y // x). apply Cong_symmetric, CongBase. 
              constructor; try assumption.
              intros H5. apply H1. right. assumption. }
        + apply CongAll. apply IH1; intros H4.
            { apply H1. right. assumption. }
            { apply H2. exfalso. apply H2. apply remove_still; assumption. }
Qed.

(* Almost strong alpha-equivalence. Will be shown to be the same.               *)
Inductive AlmostStrongAlpha (v:Type) (e:Eq v) : P v -> P v -> Prop := 
| ABot : AlmostStrongAlpha v e Bot Bot
| AElem : forall (x y:v), AlmostStrongAlpha v e (Elem x y) (Elem x y)
| AImp  : forall (p1 p2 q1 q2:P v), 
    p1 ~ q1 -> 
    p2 ~ q2 -> 
    AlmostStrongAlpha v e (Imp p1 p2) (Imp q1 q2)
| AAllx : forall (x:v) (p1 q1:P v), 
    p1 ~ q1 -> 
    AlmostStrongAlpha v e (All x p1) (All x q1)
| AAllxy : forall (x y:v) (p1 q1 r:P v),
    x <> y               ->
    p1 ~ r               ->
    q1 ~ fmap (y // x) r ->
    ~ y :: var r         ->
    AlmostStrongAlpha v e (All x p1) (All y q1)
.

Arguments AlmostStrongAlpha {v} {e}.

Notation "p :~: q" := (AlmostStrongAlpha p q)
    (at level 60, no associativity) : Fol_StrongAlpha_scope.

Open Scope Fol_StrongAlpha_scope.

Lemma almostImpRev : forall (v:Type) (e:Eq v) (p1 p2 q:P v), 
    Imp p1 p2 :~: q -> exists (q1 q2:P v),
        (p1 ~ q1) /\ (p2 ~ q2) /\ (q = Imp q1 q2).
Proof.
    intros v e p1 p2 q H1. remember (Imp p1 p2) as p eqn:E. revert p1 p2 E.
    destruct H1 as [|x y|p1' p2' q1 q2 H1 H2|x p1' q1|x y p1' q1 r H1 H2 H3 H4];
    intros p1 p2 E; inversion E. subst. exists q1. exists q2.
    split; try assumption. split; try assumption. reflexivity.
Qed.

(*
Lemma almostAllRev : forall (v:Type) (e:Eq v) (p1 q:P v) (x:v),
    All x p1 :~: q -> 
        (exists (q1:P v), (p1 ~ q1) /\ (q = All x q1)) \/
        (exists (q1 r:P v) (y:v),
            (x <> y)                /\ 
            (p1 ~ r)                /\ 
            (q1 ~ fmap (y // x) r)  /\
            (~ y :: var r)          /\
            (q = All y q1)).
Proof.

Show.
*)
(*
    intros v e p q1 y H1. remember (All y q1) as q eqn:Q. revert y q1 Q.
    destruct H1 as [|x y'|p1 p2 q1' q2' H1 H2|x p1 q1'|x y' p1 q1' r H1 H2 H3 H4];
    intros y q1 Q; inversion Q; subst.
    - left. exists p1. split; try assumption. reflexivity.
    - right. exists p1. exists r. exists x.
      split; try assumption. 
      split; try assumption.
      split; try assumption.
      split; try assumption.
      reflexivity.
Qed.


(* Almost equivalence contains generator of strong alpha-equivalence.           *)
Lemma almostSrongAlpha0 : forall (v:Type) (e:Eq v),
    @StrongAlpha0 v e <= @AlmostStrongAlpha v e.
Proof.
    intros v e. apply incl_charac. intros p q H1.
    destruct H1 as [x y p1 H1 H2]. apply AAllxy with p1;
    try assumption; try (apply Cong_reflexive).
Qed.

(* Almost equivalence is reflexive.                                             *)
Lemma almostRefl : forall (v:Type) (e:Eq v) (p:P v), p :~: p.
Proof.
    intros v e p. destruct p as [|x y|p1 p2|x p1]; 
    try constructor; try (apply Cong_reflexive).
Qed.

(* Almost equivalence is symmetric.                                             *)
Lemma almostSym : forall (v:Type) (e:Eq v) (p q:P v), p :~: q -> q :~: p.
Proof.
    intros v e p q H1. 
    destruct H1 as [|x y|p1 p2 q1 q2 H1 H2|x p1 q1|x y p1 q1 r H1 H2 H3 H4].
    - constructor.
    - constructor.
    - constructor; apply Cong_symmetric; assumption.
    - constructor. apply Cong_symmetric. assumption.
    - apply AAllxy with (fmap (y // x) r).
        + intros H5. apply H1. symmetry. assumption.
        + assumption.
        + apply Cong_transitive with r; try assumption.
          assert (r = fmap (x // y) (fmap (y // x) r)) as H5.
            { rewrite var_replace_trans; try assumption.
              rewrite replace_x_x. rewrite fmap_id. reflexivity. }
          rewrite <- H5. apply Cong_reflexive.
        + apply var_replace_remove. assumption.
Qed.
*)

(*
Lemma almostTrans : forall (v:Type) (e:Eq v) (p q r:P v),
    p :~: q -> q :~: r -> p :~: r.
Proof.
    intros v e p q r H1. revert r.
    destruct H1 as [|x y|p1 p2 q1 q2 H1 H2|x p1 q1|x y p1 q1 r H1 H2 H3 H4];
    intros r' H5.
    - assumption.
    - assumption.
    - apply almostSym in H5. apply almostImpRev in H5. 
      destruct H5 as [p1' [p2' [H5 [H6 H7]]]]. rewrite H7. constructor. 
        + apply Cong_transitive with q1; try assumption.
          apply Cong_symmetric. assumption.
        + apply Cong_transitive with q2; try assumption.
          apply Cong_symmetric. assumption.
    - apply almostSym in H5. apply almostAllRev in H5. destruct H5 as [H5|H5].
        + destruct H5 as [r1 [H5 H6]]. subst. constructor.
          apply Cong_transitive with q1; try assumption. 
          apply Cong_symmetric. assumption.
        + destruct H5 as [r1 [s1 [y [H5 [H6 [H7 [H8 H9]]]]]]]. subst.
          apply almostSym. apply AAllxy with s1; try assumption.
          apply Cong_transitive with q1; assumption.
    - apply almostSym in H5. apply almostAllRev in H5. destruct H5 as [H5|H5].
        + destruct H5 as [r1 [H5 H6]]. subst. 
          apply AAllxy with r; try assumption. 
          apply Cong_transitive with q1; assumption.
        + destruct H5 as [r1 [s [z [H5 [H6 [H7 [H8 H9]]]]]]]. subst.
          destruct (eqDec x z) as [H10|H10].
            { subst. constructor. assert (r ~ s) as H9.
                { change (id r ~ id s). rewrite <- fmap_id.
                  rewrite <- (permute_involution v e y z).
                  rewrite fmap_comp', fmap_comp'.
                  apply (StrongAlpha_injective _ _ _ _); 
                  try (apply permute_injective).
                  rewrite permute_comm.
                  rewrite <- var_replace_permute; try assumption.
                  rewrite <- var_replace_permute; try assumption.
                  apply Cong_transitive with q1 ; try assumption.
                  apply Cong_symmetric. assumption. }
              apply Cong_transitive with r; try assumption.
              apply Cong_transitive with s; try assumption.
              apply Cong_symmetric. assumption. }
            {
        
Show.
*)
