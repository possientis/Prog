Require Import Logic.Rel.R.
Require Import Logic.Rel.Include.
Require Import Logic.Rel.Properties.

Require Import Logic.Fol.Syntax.
Require Import Logic.Fol.Functor.


Definition congruent (v:Type) (r:Rel (P v)) : Prop := 
    (forall (p1 p2 q1 q2:P v), r p1 q1 -> r p2 q2 -> r (Imp p1 p2) (Imp q1 q2)) /\
    (forall (x:v) (p1 q1:P v), r p1 q1 -> r (All x p1) (All x q1)).

Arguments congruent {v} _.

Definition congruence (v:Type) (r:Rel (P v)) : Prop :=
   equivalence r /\ congruent r. 

Arguments congruence {v} _.

Lemma fmap_congruence : forall (v w:Type) (f:v -> w) (r:Rel (P w)),
    congruence r -> congruence (fun (p q:P v) => r (fmap f p) (fmap f q)).
Proof.
    intros v w f r [H1 [HImp HAll]]. 
    unfold equivalence in H1. destruct H1 as [Refl [Symm Tran]].
    unfold reflexive in Refl.
    unfold symmetric in Symm.
    unfold transitive in Tran.
    split.
    - split.
        + unfold reflexive. intros x. apply Refl.
        + split.
            { unfold symmetric. intros x y. apply Symm. }
            { unfold transitive.  intros x y z. apply Tran. }
    - split.
        + intros s1 s2 t1 t2. apply HImp.
        + intros x s1 t1. apply HAll.
Qed. 

(* Congruence relation generated by a given relation on P v.                    *)
Inductive Cong (v:Type) (r:Rel (P v)) : Rel (P v) :=
| CongBase  : forall (p q:P v), r p q -> Cong v r p q
| CongRefl  : forall (p:P v), Cong v r p p
| CongSym   : forall (p q:P v), Cong v r p q -> Cong v r q p
| CongTrans : forall (p q t:P v), Cong v r p q -> Cong v r q t -> Cong v r p t
| CongImp   : forall (p1 p2 q1 q2:P v), 
    Cong v r p1 q1 -> 
    Cong v r p2 q2 ->
    Cong v r (Imp p1 p2) (Imp q1 q2)
| CongAll   : forall (x:v) (p1 q1:P v),
    Cong v r p1 q1 ->
    Cong v r (All x p1 )(All x q1)
.
  
Arguments Cong      {v}.
Arguments CongBase  {v}.
Arguments CongRefl  {v}.
Arguments CongSym   {v}.
Arguments CongTrans {v}.
Arguments CongImp   {v}.
Arguments CongAll   {v}.

(* The congruence relation generated by a given relation is reflexive.          *)
Lemma Cong_reflexive : forall (v:Type) (r:Rel (P v)), reflexive (Cong r).
Proof.
    intros v r. unfold reflexive. intros x. apply CongRefl.
Qed.

(* The congruence relation generated by a given relation is symmetric.          *)
Lemma Cong_symmetric : forall (v:Type) (r:Rel (P v)), symmetric (Cong r).
Proof.
    intros v r. unfold symmetric. intros x y. apply CongSym.
Qed.

(* The congruence relation generated by a given relation is transitive.         *)
Lemma Cong_transitive : forall (v:Type) (r:Rel (P v)), transitive (Cong r).
Proof.
    intros v r. unfold transitive. intros x y. apply CongTrans.
Qed.

(* The congruence relation generated by a given relation is an equivalence.     *)
Lemma Cong_equivalence : forall (v:Type) (r:Rel (P v)), equivalence (Cong r).
Proof.
    intros v r. unfold equivalence. split.
    - apply Cong_reflexive.
    - split.
        + apply Cong_symmetric.
        + apply Cong_transitive.
Qed.

(* The congruence relation generated by a given relation is congruent.         *)
Lemma Cong_congruent : forall (v:Type) (r:Rel (P v)), congruent (Cong r).
Proof.
    intros v r. unfold congruent. split.
    - apply CongImp.
    - apply CongAll.
Qed.

(* The congruence relation generated by a given relation is a congruence.       *)
Lemma Cong_congruence : forall (v:Type) (r:Rel (P v)), congruence (Cong r).
Proof.
    intros v r. unfold congruence. split.
    - apply Cong_equivalence.
    - apply Cong_congruent.
Qed.

(* The congruence relation generated by a given relation contains it.           *)
Lemma Cong_super : forall (v:Type) (r:Rel (P v)), r <= Cong r.
Proof.
    intros v r. apply incl_charac. intros x y. apply CongBase.
Qed.

(* The congruence relation generated by a given relation is the smallest.       *)
Lemma Cong_smallest : forall (v:Type) (r s:Rel (P v)), 
    congruence s -> r <= s -> Cong r <= s.
Proof.
    intros v r s [[H1 [H2 H3]] [H4 H5]] H6. apply incl_charac. intros x y H7.
    induction H7 as [p q H7|p|p q H7 IH|p q t H7 H8 H9 IH
                    |p1 p2 q1 q2 H7 IH1 H8 IH2|x p1 q1 H7 IH].
    - apply incl_charac_to with r; assumption.
    - apply H1.
    - apply H2. assumption.
    - apply H3 with q; assumption.
    - apply H4; assumption.
    - apply H5. assumption.
Qed.
