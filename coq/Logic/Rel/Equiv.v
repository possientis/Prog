Require Import Logic.Rel.R. 
Require Import Logic.Rel.Include.
Require Import Logic.Rel.Properties.

(* Equivalence relation generated by a given relation on Type a.                *)
Inductive Equiv (a:Type) (r:Rel a) : Rel a :=
| EquivBase : forall (x y:a), r x y -> Equiv a r x y
| EquivRefl : forall (x:a), Equiv a r x x
| EquivSym  : forall (x y:a), Equiv a r x y -> Equiv a r y x
| EquivTrans: forall (x y z:a), Equiv a r x y -> Equiv a r y z -> Equiv a r x z
.

Arguments Equiv      {a}.
Arguments EquivBase  {a}.
Arguments EquivRefl  {a}.
Arguments EquivSym   {a}.
Arguments EquivTrans {a}.

Lemma Equiv_reflexive : forall (a:Type) (r:Rel a), reflexive (Equiv r).
Proof.
    intros a r. unfold reflexive. intros x. apply EquivRefl.
Qed.

Lemma Equiv_symmetric : forall (a:Type) (r:Rel a), symmetric (Equiv r).
Proof.
    intros a r. unfold symmetric. intros x y H1. apply EquivSym. assumption.
Qed.

Lemma Equiv_transitive : forall (a:Type) (r:Rel a), transitive (Equiv r).
Proof.
    intros a r. unfold transitive. intros x y z H1 H2. 
    apply EquivTrans with y; assumption.
Qed.

Lemma Equiv_equivalence : forall (a:Type) (r:Rel a), equivalence (Equiv r).
Proof.
    intros a r. unfold equivalence. split.
    - apply Equiv_reflexive.
    - split.
        + apply Equiv_symmetric.
        + apply Equiv_transitive.
Qed.

Lemma Equiv_super : forall (a:Type) (r:Rel a), r <= Equiv r.
Proof.
    intros a r. apply incl_charac. intros x y H1. apply EquivBase. assumption.
Qed.

Lemma Equiv_smallest : forall (a:Type) (r s:Rel a),
    equivalence s -> r <= s -> Equiv r <= s.
Proof.
    intros a r s [H1 [H2 H3]] H4. apply incl_charac. intros x y H5.
    induction H5 as [x y H5|x|x y H5 IH|x y z H5 H6 H7 IH].
    - apply incl_charac_to with r; assumption.
    - apply H1.
    - apply H2. assumption.
    - apply H3 with y; assumption.
Qed.
