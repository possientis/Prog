continue rewriting unit-test

understand possible dissymetry of include between "analyze.scm" and "strict/lazy-eval.scm". do we need to create new type of procedure? strict-eval-procedure v lazy-eval-procedure? (see application.scm for obvious dissymetry, should there be a strict-apply, analyze-apply, lazy-appply?)
analyze: review code and understand why no pick up in perf

lazy-repl:
(define (error) (display "This is an error\n"))
understand why:
> (error) 
fails

(define (try a b) (if (= 0 a) 1 b))
compare lazy and strict eval of
> (try 0 (error))




define primitives from language itself
implement macros
lazy evaluation of arguments (with or without memoization)
change semantics of apply
check semantics of '() vs ()
incorporate frame4 with hash-table library

